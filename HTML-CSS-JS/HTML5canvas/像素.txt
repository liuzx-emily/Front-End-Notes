1 属性
	width	返回ImageData对象的宽度，px为单位
	height	返回ImageData对象的高度
	data	返回一个对象，其包含指定的ImageData对象的图像数据。
2 方法
	createImageData  创建新的、空白的ImageData对象
	getImageData  返回ImageData对象，该对象为画布上指定的矩形复制像素数据
	putImageData  把图像数据（从指定的ImageData对象）放回画布上


----------------
	*date属性*
对于ImageData对象中的每个像素，都存在着四方面的信息，即 RGBA 值：
	R - 红色（0-255）
	G - 绿色（0-255）
	B - 蓝色（0-255）
	A - alpha 通道（0-255; 0 是透明的，255 是完全可见的）
color/alpha 信息以数组形式存在，并存储于ImageData对象的 data 属性中。

----------------
	*createImageData*
1. 以指定的尺寸（以像素计）创建新的ImageData对象：
	var imgData=context.createImageData(w,h);
2. 创建与指定的另一个ImageData对象尺寸相同的新ImageData对象
  （不会复制图像数据）
	var imgData=context.createImageData(imageData);

----------------
	*getImageData*
context.getImageData(x,y,w,h);

----------------
	*putImageData*
context.putImageData(imgData,x,y)

----------------
	*实例：1 画一个渐变小方块
说明：
1 i是行数：0-oImg.height，j是列数：0-oImg.width
  第i行第j列：是第i*oImg.width+j个像素点
  在data数组中这个像素点占4个位置，起始位置是：4*(i*oImg.width+j)
2 渐变：
  第一行是(0,0,0,255) 最后一行是(255,0,0,255) 
  red根据i在变：Math.round(255 / oImg.height * i)

更多见html文件：
	for (let i = 0; i < oImg.height; i++) {
        for (let j = 0; j < oImg.width; j++) {
            let startIndex = 4 * (i * oImg.width + j);
            oImg.data[startIndex + 0] = Math.round(255 / oImg.height * i);
            oImg.data[startIndex + 1] = 0;
            oImg.data[startIndex + 2] = 0;
            oImg.data[startIndex + 3] = 255;
        }
    }

----------------
	*实例：2 沫沫效果
(基于“文字.html”)
1 先把文字显示在画布上，然后存起来得到ImageData对象myText
2 最初的文字显示只用了得到ImageData，不能让user看到，所以获得ImageData后需要立刻清空画布。
3 新建ImageData对象newText，把myText中的一部分像素点赋值给newText
  使用randNum函数：randNum(w * h, w * h / 5)
	共有w*h个像素点，只取其中的五分之一

----------------
	*实例：3 沫沫至完全显示
基于“像素-2 沫沫.html”
1 修改randNum函数：
	newArr存了iAll / iWant个数组
2 var newText = ctx.createImageData(myText);这句要放在定时器外面
  即newText只建立一次，之后都是在newText上不断设置新的像素点

----------------
	*封装函数
为了方便，封装函数用来便捷的取、设置像素点：
	function getXY(obj, x, y) {
	    var w = obj.width;
	    var h = obj.height;
	    var sIndex = 4 * (x + y * w);
	    var color = [];
	    for (var i = 0; i < 4; i++) {
	        color.push(obj.data[sIndex + i]);
	    }
	    return color;
	}

	function setXY(obj, x, y, color) {
	    var w = obj.width;
	    var h = obj.height;
	    var sIndex = 4 * (x + y * w);
	    for (var i = 0; i < 4; i++) {
	        obj.data[sIndex + i] = color[i];
	    }
	}
注意:只设置一个像素点的颜色是看不出来的


-------------------------
	*跨域问题*
1 canvas不能跨域
2 chrome下的“伪跨域”问题：
	getImageData用的本地图片，在chrome下还是会报错：跨域。在FF和IE都能正常显示。
	因为chrome把file://当作是跨域。
	开启服务器环境后，在localhost下打开一切正常。

	

-------------------------
	*读取图片的data*
先把图片添加进去，再读取画布中相应部分的data
（有chrome下file://跨域的问题，记得在FF或IE中查看）
var oImg = new Image();
oImg.onload = function() {
    var w = 400;
    var h = 250;
    ctx.drawImage(oImg, 0, 0, w, h);
    var myImg = ctx.getImageData(0, 0, w, h); //chrome下本地测试会报错

};
oImg.src = '1.jpg';

-------------------------
	*实例：变图片颜色*
1 彩色变黑白
2 图片变反色
原理都一样

-------------------------
	*实例：将图片颠倒
1 跟上面变颜色不同
	这里不能直接用get到的data对象，要新建一个。(有点乱？？有空想一想)

	var myImg = ctx.getImageData(0, 0, w, h);
	var newImg = ctx.createImageData(w, h);
	for (let i = 0; i < myImg.width; i++) {
	    for (let j = 0; j < myImg.height; j++) {
	        let aColor = getXY(myImg, i, j);
	        setXY(newImg, w - i, h - j, aColor);
	    }
	}
	ctx.putImageData(newImg, 0, h);
2 顺道调了一下透明度

-------------------------
	*实例：马赛克
iP = 5规定了马赛克大小是5*5	
i代表马赛克块的第几列，j代表马赛克块的第几行
x,y是在当前"马赛可块"中随机选一个像素点，作为整个块的颜色

m,n两层循环是给每个"马赛克块"设置颜色
	for (let i = 0; i < w / iP; i++) {
	    for (let j = 0; j < h / iP; j++) {
	        let x = i * iP + Math.floor(Math.random() * iP);
	        let y = j * iP + Math.floor(Math.random() * iP);
	        var color = getXY(myImg, x, y);
	        for (let m = 0; m < iP; m++) {
	            for (let n = 0; n < iP; n++) {
	                setXY(myImg, i * iP + m, j * iP + n, color);
	            }
	        }
	    }
	}
注：只考虑了w/iP和h/iP都为整数的情况