当前路径打开cmd：
	1 shift + 鼠标右键
	2 地址栏输入cmd



-------------------let和const命令-------------------

1 只在声明的块内有效
	let经常用在for循环中，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。
	设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
		for (let i = 0; i < 3; i++) {
		  let i = 'abc';
		  console.log(i);
		}
	输出3个'abc'

2 不存在变量提升

	console.log(foo); //undefined
	var foo = 2;
	console.log(bar); //报错
	let bar = 2;

3 不允许重复声明
	function func(a) {
		let a; // 报错
	}

4 let const的暂时性死区 temporal dead zone
	ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
		let a=5;
		{
			console.log(a);	// 报错
			let a=9;
		}

5 块级作用域
	ES5只有全局作用域和函数作用域
	let和const为js新增了块级作用域
	本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值

6 const额外特点：
	1 声明时，必须初始化
	2 值类型：常量
	  引用类型：指向不变

7 顶层对象的属性
	1 为了保持兼容性，var和function声明的全局变量，依旧是顶层对象的属性
	2 let、const、class声明的全局变量，不属于顶层对象的属性
		var a = 1;
		window.a 	// 1
		let b = 1;
		window.b 	// undefined

8 声明变量的方法
	ES5：var function。只有2种
	ES6：let const import class 新增4，共6




-------------------解构赋值-------------------
解构：从数组和对象中提取值，对变量进行赋值

规则：
	只要等号右边的值不是对象或数组，就先将其转为对象	
	如果等号的右边不能转为对象(null undefined)，会报错
	如果等号的右边(转为对象后)不是可遍历的结构，会报错。




-------------------解构赋值之 数组-------------------
数组：模式匹配，根据位置
	let [a, b, ...c] = [ , 2, 3, 4, 5, 6];
	a	// undefined
	b	// 2
	c	// [3,4,5,6]

	let [x, y, ...z] = ['a'];
	x 	// "a"
	y 	// undefined
	z 	// []

	let [a, [b], c] = [1, [2, 3], 4];
	b 	// 2
	c 	// 4

默认值：判断是否===undefined
	let [a = 1] = [undefined];	// 1
	let [b = 1] = [null];		// null
	let [x=1,y=x] = [];    		// x=1; y=1
	let [x=1,y=x] = [2];   		// x=2; y=2
	let [x=1,y=x] = [1, 2];		// x=1; y=2





-------------------解构赋值之 对象-------------------
1 变量和属性同名
	let { a, b, c } = { b: "hah", a: "biu" };
	a	// "biu"
	b	// "hah"
	c	// undefined
	其实是下面的简写：
	let {a:a,b:b,c:c}={ b: "hah", a: "biu" };

2 	let { foo: baz } = { foo: "aaa", bar: "bbb" };
	baz // "aaa"
	foo // 报错: foo is not defined
	这种方法证明了：对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是变量baz，而不是匹配模式foo

默认值：判断对象的属性值严格===undefined  

可以很方便地将现有对象的方法，赋值到某个变量：
	let { log, sin, cos } = Math;

由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构：
	let arr = [1, 2, 3];
	let {0 : first, [arr.length - 1] : last} = arr;
	first // 1
	last // 3





-------------------解构赋值之 字符串-------------------

字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
	let [a,b,c,d]="emily";
	// a b c d分别是"e"、"m"、"i"、"l"
	let {0:first,length:lzxLen}="abcde";
	// first: "a" lzxLen: 5





-------------------解构赋值之 函数参数-------------------
函数参数的解构赋值
	function add([x, y]){
	  return x + y;
	}
	add([1, 2]); // 3

	[[1, 2], [3, 4]].map(([a, b]) => a + b);	// [ 3, 7 ]





-------------------解构赋值之 实例-------------------

1 交换变量值 [x,y]=[y,x];

2 函数返回多个值后，方便的取出这些值
	let { foo, bar } = example();

3 方便地将一组参数与变量名对应起来

	function f([x, y, z]) { ... }
	f([1, 2, 3]);

	function f({x, y, z}) { ... }
	f({z: 3, y: 2, x: 1});

4 提取JSON数据
	let jsonData = {
	  id: 42,
	  status: "OK",
	  data: [867, 5309]
	};

	let { id, status, data: number } = jsonData;




-------------------类class-------------------
ES6中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。

传统写法：
	var Person = function(name, age) {
	    this.name = name;
	    this.age = age;
	};

	Person.prototype = {
	    constructor: Person,
	    print: function() {
	        console.log(this.name);
	    }
	};

class写法：
	class Person{
		constructor(name,age){
	    	this.name = name;
			this.age=age;
		}
		print(){
			console.log(this.a)
		}
	};
使用还是和以前一样：
	var p= new Person("haha",23);
	p.print();

说明：class只是语法糖
	1 类中定义方法的时候，前面不能加上function。方法之间不能加逗号分隔

	2 构造函数的prototype属性，在ES6的“类”上面继续存在。而且类的所有方法都定义在类的prototype属性上面。

extends static super







-----------------字符串扩展-----------------
1 模版字符串
	`${变量}` 

2 新方法 repeat(次数) includes() startsWith() endsWith()
  	
	let str1 = 'ha';
	let str2 = str1.repeat(3);	//"hahaha"

	let str = 'emily';
	str.includes('mi')  	//true
	str.includes('am')  	//false

	str.startsWith('e') 	//true
	str.startsWith('a') 	//false

	str.endsWith('ly') 		//true
	str.endsWith('ily') 	//true





-----------------数组扩展-----------------
1 Array.from()  把类数组对象转成真正的数组,不改变原对象
	var lis = document.querySelectorAll('li');
	console.log(Array.isArray(lis));	/  false
	var lis2 = Array.from(lis);
	console.log(Array.isArray(lis2));	// true

2 Array.of()
	const arr = Array.of(1,"3.5");
	console.log(arr);	//[1,"3.5"]

3 find(函数)：返回第一个匹配的元素，找不到undefined
  findIndex(函数)：返回第一个匹配的元素下标，找不到-1
  	const arr = [100, 200, 300, 400];
  	let res = arr.find(function (a){
  	  return a > 0;
  	});
  	console.log(res);	//100

  	let res = arr.findIndex(function (a){
  	  return a > 0;
  	});
  	console.log(res);	//0

4 fill(value, start, end)
	const arr = [1, 2, 3, 4];
	arr.fill('abc', 1, 3);
	console.log(arr); //[1,"abc","abc",4];

5 Array.isArray()	判断是不是数组
  IE9+







--------------对象扩展--------------
1 简洁表示法
	let a = 1;
	const obj = {
	    a: a,
	    fn: function() {}
	};
  可以写成：
  	let a = 1;
  	const obj1 = {
  	    a,
  	    fn() {}
  	}

2 Object.is() ：判断两个对象是否长得一样
	Object.is(NaN, NaN) 	//true
	Object.is(+0, -0) 		//false

3 Object.assign(目标对象，源对象..)
  用于对象的合并，将源对象的所有可枚举属性， 复制到目标对象。
	let obj1 = { a: 1 };
	let obj2 = { a: 2, b: 3 };
	let obj3 = { c: 'abc' };
	Object.assign(obj1, obj2, obj3);
	console.log(obj1);//{a:2,b:3,c:'abc'}





--------------函数扩展--------------
1 参数默认值

2 rest参数：ECMA6中不推荐使用arguments
	function sum(a,b,...args){
		//...
	}

3 箭头函数 =>

	const fn=a=>a;
  等价于
	const fn=function(a){
		return a;
	};

  参数个数不为1时，要用括号包起来
	const fn= () => "hiahia~";
	const fn= (a,b) => a+"-"+b;

  函数体可以用{}括起来
	const fn= (a,b) => {
		a=a*3+1;
		b=b*4-2;
		return a+b;
	}

  如果返回一个对象，要用()括起来，不然会被当作函数体：
	const fn1= (a,b)=> {a,b};	//{}被当作函数体
	const fn2= (a,b)=> ({a,b});	//返回一个对象{a,b}


  箭头函数经常用于方法的回调函数：
	arr.sort((a,b)=>a-b);	//升序排序

  箭头函数内没有自己的this对象，所以在使用的时候，其内部的this就是定义时所在环境的对象，而不是使用时所在环境的对象。
  不能给箭头函数使用 call apply bind
  
  箭头函数内没有arguments对象，
