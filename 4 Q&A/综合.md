


## 1 小明访问淘宝，开了多个窗口。在窗口A中修改了购物车，希望窗口B中的购物车信息能够自动刷新，怎么做？

<details><summary>答案</summary>
用`localStorage`和 window.onstorage

`window.onstorage` 可以监听同个域名下， localStorage 和 sessionStorage 的变化（导致这个变化的页面不会触发此事件）

同样：打开两个相同页面，a页面用张三登录。b页面登录李四，希望a页面此时立刻切换成李四，也可以用这个。
</details>



---



## 2 get和post的区别？ RESTful ？

<details><summary>答案</summary>

语义上：用get去读，用post去写。

get 会被缓存（老IE中，get请求会走缓存，所以得加时间戳），post不会被缓存
get请求会保存在浏览器历史记录中，post不会
1. 参数放在哪？  
   get：拼在url里  
   post：一般放在request Body中

2. 长度限制  
   http协议对get和post的长度都没有任何限制。  
   get：因为参数会拼在URL中，所以会收到浏览器对url长度的限制。  

3. 安全性
   参数都是明文传输，都不安全。


RESTful：一种 API （接口）设计规范

- 参数命名规范：驼峰、下划线
- url 命名规范：通过HTTP方法表示具体操作（GET 查询；POST 新增；PUT修改；DELETE删除），url中不写出是什么操作。比如：
  - GET /zoos：列出所有动物园
  - POST /zoos：新建一个动物园（上传文件）
  - GET /zoos/ID：获取某个指定动物园的信息
  - PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
  - DELETE /zoos/ID：删除某个动物园
  - GET /zoos/ID/animals：列出某个指定动物园的所有动物
  - DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物

</details>



---






## 3 HTTP状态码含义

200 301 302 304 400 401 403 405 500
<details><summary>答案</summary>

- 200 成功
- 301 永久重定向；302 临时重定向
- 304 请求的资源没有被修改过读的是缓存
- 400 Bad request，一般是传参方式错误
- 401 认证错误或缺失，可能是没有携带token；403 服务器拒绝处理这个请求，一般是权限问题（和401的区别是，有认证，但是认证完发现这个人权限不够）
- 405 Method not allowed，比如post写成get了
- 500 服务器内部错误
</details>

---

## 4 label 标签的作用

增大单选、多选的点击范围，方便用户（label 的 for属性 === input 的 id ）
```html
<label for="swim">游泳</label>
<input type="radio" id="swim" name="hobby">
<label for="dance">跳舞</label>
<input type="radio" id="dance" name="hobby">
  ```

  ---
  
  ## 5 面渲染html的过程？
- (去 DNS 服务器，根据域名查询 IP 地址，访问这个地址 )
- 解析 html的内容，构建 DOM 树（每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。此时只有结构。）
- 解析的同时获取 css 、js、图片等资源文件
- 解析 css 代码，计算出最终的 css 样式，解析时优先级从低到高：（继承的样式<直接的样式）
  - 浏览器默认
  - 外部的css 文件、html 的 style 标签（这俩同权重，就看写的顺序了）（同权重的话，最后的生效）。优先级：
    - 通用 *
    - 标签 p
    - 类选择器 .class，属性选择器[type="radio"]，伪类 :hover
    - id
  - 行内样式
  - `!important`
- DOM树+最终css样式 =>构建渲染树 rendering tree （区别：DOM树完全和html标签一一对应；渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲中都是独立的一个节点，这每一个节点都存储有对应的css属性。）
- 根据渲染树，在页面上画出来

  如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。

  ---

## 6  跨域是什么？怎么解决？CORS是什么？


跨域：浏览器默认的安全策略，是不允许跨域获取资源的。

协议、域名、端口号都一样，才算同域。下面都是跨域：
- 域名不同（www.a.com 和 www.b.com）
- 协议不同 （http://a.com 和 https://a.com）
- 一级域名相同，二级域名不同 （www.a.com 和 haha.a.com）（www.a.com 和 a.com 也不行）
- 端口号不同 (www.a.com 和 www.a.com:7000)
- 域名和域名对应的ip（www.a.conm 和 70.50.29.12）

解决跨域常用两种方法：
- 1 代理服务器
  webpack 、vue-cli 中使用 devServer；nginx
- 2 cors 具体见下
- 3 jsonp 

jsonp：
- 利用 script 标签没有跨域限制的“漏洞。（传输的就是js文件，）
- `<script src="http://a.com/api?param=1&callback=cb"></script>`（
cb 是回调函数，用来接收数据）。第三方产生的响应为 json 数据的包装（故称之为jsonp，即json padding），形如：`cb({"name":"hax","gender":"Male"})` 。这样浏览器会调用 cb 函数，并传递解析后json对象作为参数


CORS：
 - cross-origin resource sharing 跨域资源共享。服务器可以自己决定是否允许跨域请求。
- 通过设置 http 头，如 `Access-Control-Allow-Origin: http://www.a.com`  可设置为* ，所有域都能访问

---

## 7 如何中断ajax请求？

- 设置超时自动断开
- 手动停止，ajax.abort()

---

## 8 eventloop？宏任务、微任务？

主线程是单线程的。
浏览器有其他模块处理，DOM模块、定时器模块等等。

主线程中按顺序执行，定时器 setTimeout，交给定时器模块去处理。到时间后，定时器模块把cb放到宏任务队列中。
遇到 promise 的回调，触发 cb 后把它放入微任务队列中处理。

主线程中的任务执行完，清空微任务，执行一个宏任务。如此循环


宏任务：script setTimeout setInterval postMessage
微任务：promise

执行一个宏任务 -> 执行所有微任务 -> 浏览器渲染 -> 执行下一个宏任务


---




## 9 export 和  export default 的区别？

一个js文件就是一个模块。模块内部的变量，外部无法获取。通过 export 向外输出变量，别的模块通过 import 引入。

使用 export 的两种写法：
```js
// export 写法1（不推荐，分散写，乱）
export var a=1;
export function b(){};
// export 写法2（推荐，统一在底部 export，更清晰）
var a=1;
var b=2;
function c(){};
export {a,b,c};
// 别的模块引用时，需要知道变量的名称
import {a,c} from 'tools.js';
```
export default 为模块指定默认输出，每个模块只能有一个。（本质上是输出一个叫做default的变量或方法，别的模块引用时可以任意取名字）

```js
// 输出
export default var a=1;
// 其他模块引用时，可以任意取名字
import randomName from './m.js'
```

---


## 10 常用的 ES6 功能

简单的：
- let const（语义更清晰，和 var 的区别：不会变量提升，不会成为 window 的属性，for循环时用 let 和 var 的区别）
- 模板字符串：反引号 `My name is ${name}, I love {hobby}`
- 解构赋值（ `let [a,b,c]=[1,2,3];` `let {a,b}={a:1,b:2};const {log,sin,cos}=Math;`
- str 的新方法：`includes` , `startsWith` , `endsWith` , `'hi'.repeat(3)//结果为'hihihi'`
- arr的新方法：`includes` `Array.from(类数组对象，或者 Set) `
- 函数的默认参数 function(x,y=1){}
- 扩展运算符 var arr=[...arr1,...arr2]; // 合并数组

高级的：
- promise ：文件的操作，读取文件夹和文件时，计算文件 MD5
- class 云盘的文件列表 File FileList 用 class 去管理
- 模块 工具函数.js 配置.js 开发时用到的假数据.js 都用 export 和 Import  

---



## 11 前端性能优化