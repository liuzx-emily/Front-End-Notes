--------------
	*建议*
把正则存在一个object里
var re = {
	qq : /[1-9][0-9]{4,9}/,
	email : /^\w+@[a-z0-9]+(\.[a-z]+){1,3}$/
};


一些常用的
	匹配中文：[\u4e00-\u9fa5]
	行首行尾空格：^\s*|\s*$
	Email：^\w+@[a-z0-9]+(\.[a-z]+){1,3}$
	网址：[a-zA-z]+://[^\s]*
	QQ号：[1-9][0-9]{4,9}
	邮政编码：[1-9]\d{5}
	身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x




--------------
	*知识点总结*
创建正则对象
修饰符
字符类
元字符（转义字符）
量词
起始和结束
RegExp对象方法
支持正则表达式的 String 对象的方法



--------------
	*课后练习*
1 匹配紧邻的成对的标签
	var str = '<div><p></p><span></span></div>';
	结果[ '<p></p>', '<span></span>' ]
2 判断输入是不是13-99之间年龄
3 -转换成驼峰
	var str = 'border-bottom-color';
	变为[borderBottomColor]
4 过滤标签:把html格式的内容去掉标签变为纯文本。：
	var str = "<div class='red' id='title'><p>这是段落1</p><p>这是段落2</p></div>";
	结果："这是段落1这是段落2"
5 判断qq号:5-12位数字，第一位不能是0
6 敏感词过滤
	var oldStr = '中国五星红旗美利坚星条旗英国米字旗';
	输出：**五星红旗***星条旗**米字旗



练习题答案：
1 匹配紧邻的成对标签
	var re = /<([^<]+)><\/\1>/g;
2 判断输入是不是13-99之间年龄
	var re = /^(1[3-9]|[2-9]\d)$/;	//要加^和$
3 -转换成驼峰
	var re = /-([a-z])/g;
	var newStr = str.replace(re, function(match, p1) {
	   return p1.toUpperCase();
	});
	或者：
	var re = /-[a-z]/g;
	var newStr = str.replace(re, function(match) {
	   return match[1].toUpperCase();
	});
4 过滤标签:把html格式的内容去掉标签变为纯文本。：
   	var re = /<[^<]+>/g;
	var newStr = str.replace(re, '');
	console.log(newStr);
5 判断输入是不是qq号:5-12位数字，第一位不能是0
	re = /^[1-9]\d{4,11}$/;	//要加^和$
6 敏感词过滤
	var re=/中国|美利坚|英国/g;
	var newStr = oldStr.replace(re, function(match) {
	   var result = '';
	   for (var i = 0; i < match.length; i++) {
	      result += '*';
	   }
	   return result;
	});





--------------
	*自己写的：匹配数字*
说明：可以找所有整数、小数；正数、负数、0
	var re = /[+-]?(([1-9]\d*)|0)(\.\d+)?/g;
 1 符号：[+-]?
 2 整数部分：([1-9]\d*)|0
	整数部分不为0：[1-9]\d*（最高位不能是0，除非只有1位）
	整数部分就是0：0
 3 小数部分：(\.\d+)?
	小数点：\.
	小数：\d+ (全0也可以)



--------------
	*两种定义方法*
1 var re = /a/gi;
2 var re = new RegExp('a','gi');



--------------
	修饰符
1 i：不区分大小写
2 g：全局匹配



--------------
	字符类[]

	[abc]:a或b或c
	[a,b]:a或逗号或b
	[a b]:a或空格或b

如果^写在[]里面，就代表排除的意思(如果^出现在正则的最开始位置，就代表起始的意思)
	[^abc]:除了abc的所有

范围：
	[a-z] [A-Z] [0-9] [\u4e00-\u9fa5]（中文）
	[a-z0-9A-Z]
	[b-f]也行，只要范围从小到大



--------------
	元字符Metacharacter（转义字符）
.  ：任意字符，除了换行和行结束符。
\s : 空白字符 （包括空格、tab、回车等）
\d : 数字
\w : 字符 (字母 数字 下划线)，等价于[0-9a-zA-Z_]
\b : 独立的部分 (起始 结束 空格)
\S : 非空白字符
\D : 非数字
\W : 非字符
\B : 非独立的部分

\\ ：真正的\ (在str中真正的\也是\\，因为\在str里起换行的作用)
\/ : 真正的/
\. ：真正的点

例子：
	var str = 'onetwo';
	re = /one\b/;	//匹配不到
	re = /\bone/;	//匹配到

\1 : 重复的第一个子项（放在小括号里的。必须跟第一个子项的值一样）
\2 : 重复的第二个子项
	例子：
		re = /(a)(b)(c)\2/;	等价于re = /(a)(b)(c)b/
		re = /(\d)\1/;		不等价re = /\d\d/
		re = \d\d 		可以匹配任意两位数
		re = (\d)\1 	只能匹配22 33这种

--------------
	量词
{4,7}：最少4次，最多7次
{4,} ：最少4次,最多不限
{,7} ：最少不限，最多7次
{4}  ：正好4次
+ : 相当于{1,}
* : 相当于{0,}
? : 相当于{0,1}

--------------
	起始 结束
^ : 如果出现在正则的最开始位置，就代表起始的意思
    (^写在[]里面的话，就代表排除的意思)
$ : 如果出现在正则的最后位置 , 就代表结束的意思
例子：去掉前后空格 re = /^\s+|\s+$/g ;

--------------
	*小括号*
小括号的作用：分组 & 匹配子项
1 分组操作

2 匹配子项(转义字符\1 \2，replaced的函数里面的参数p1 p2..)
	var old = '3-2-1';
	var re = /(\d)(-)/g;
	var new = old.replace(re, function (match, p1, p2, offset, string) {
		console.log(打印参数);
	 	return p1+ ' ';
	});
	console.log('old:' + old);
	console.log('new:' + new);
	
	结果：
		match:3-, p1:3, p2:-, offset:0, string:3-2-1
		match:2-, p1:2, p2:-, offset:2, string:3-2-1
		old:3-2-1
		new:3 2 1

3 匹配子项 match:
 
	var old = '3-2-1';
	var re = /(\d)(-)/;	//match不加g时，可得到子项的集合
	var new = old.match(re);
	cl(new);	//[ '3-', '3', '-', index: 0, input: '3-2-1' ]

	var old = '3-2-1';
	var re = /(\d)(-)/g;
	var new = old.match(re);
	cl(new);	//[ '3-', '2-' ]



--------------
	RegExp 对象方法
1 test 匹配成功就返回true，失败false
	var str = 'abcdef';
	var re = /b/;
	re.test(str);		//返回true

2 compile
3 exec



--------------
	支持正则表达式的 String 对象的方法
1 split

2 search
  如果匹配成功，就返回匹配成功的位置；匹配失败就返回-1
  （找到多个的话，只返回第一个的位置）
	var str = 'abcdef';
	var re = /d/i;
	str.search(re);		//返回3

3 match
  如果匹配成功，就返回匹配成功的数组；不成功，就返回null
	var str = '6.7a,哈59.;bc';
	var re = /\d+/g;
	str.match(re); 	//返回[ '6', '7', '59' ]

4 replace【不修改原string】
	var old = 'aaa';
	var new = old.replace(/a+/, 'b');
	console.log(new);//b
	
	var new2= old2.replace(re,function(match,p1,p2,offset,string){
		return `${p1}-${p2}`;
	});


--------------
	*实例：找重复项最多的字符和个数*
关键点：使用\1来找重复的“不确定项”
	var str = 'ass+w+dss/mal1.adf29x69=/*+/.?sss?ukjsds';
	//先排序
	str = str.split('').sort().join('');
	var value = '';
	var number = 0;
	var re = /([\d\D])\1+/g;
	str.replace(re, function(match, p1) {
	   if (number < match.length) {
	      number = match.length;
	      value = p1;
	   }
	});
	console.log('最多的字符:' + value + ',重复的次数:' + number);
结果：最多的字符:s,重复的次数:9

--------------
	*实例：getByClass方法*
关键点：
 1 当正则需要传参的时候，一定要用new RegExp的写法来定义
 2 new RegExp('\\b'+sClass+'\\b')中的\b要写成\\b

	function getByClass(oParent,sClass){
		var arr = [];
		var aEle = oParent.getElementsByTagName('*');
		var re = new RegExp('\\b'+sClass+'\\b',"i");		
		for(var i=0;i<aEle.length;i++){
			if( re.test(aEle[i].className) ){
				arr.push( aEle[i] );
			}
		}		
		return arr;		
	}


	

