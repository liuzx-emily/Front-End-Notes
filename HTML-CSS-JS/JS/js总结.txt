
-------------文档声明-------------【start】
很多问题都是因为文档声明：
	html声明改为html5：	<!DOCTYPE html>



--------------------------
undefined==false 	// false
null==false 		// false
0==false 			// true




-----------------alert-----------------
alert()只能弹出字符串，非string会自动调用toString

	var a=[1,2,3];
	Array.prototype.toString=function(){
		return "改了";
	}
	alert(a);			//"改了"
	console.log(a);		//[1,2,3]





--------------前后台数据交互的方法--------------
1 表单form
	<input type="submit">
	form1.submit();

2 ajax

3 url后边带参数
	<a href="page2.html?user=emily">提交</a>
	window.location.href="page2.html?user=emily"




--------------------
	*焦点*
1 获取焦点：只有部分元素能获取焦点 from元素 a...
	a.点击  b.tab键切换  c.焦点函数
	
2 事件
	onfocus
	onblur（注册时，验证用户名是否重名）

3 函数
	obj.focus()
	obj.blur()
	obj.select()：选择指定元素里面的文本内容,同样也是只能操作部分元素

4 样式
	:focus （IE8+）


-----------------数据类型-----------------
1 根据typeof分类：5+1
  1 number 
  2 string 
  3 boolean 
  4 object  包括{}、[]、Date、null、DOM和BOM对象等
  5 function 
  6 undefined

2 根据所存内容：值类型 + 引用类型


  		

-----------------数据类型之 值类型-----------------
值类型：number string boolean null undefined

基本类型：number string boolean，有对应的包装对象Number String Boolean
	var str1 = 'hello';
	var str2 = new String('hello');	//不推荐这么写
	alert(typeof str1);	//"string"
	alert(typeof str2);	//"object"
	var str='Phil';
	str.length		//4
	str.charAt(0)	//P

基本类型不是对象，那么为什么和对象一样有属性和方法呢？
	调用属性、方法时：找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型，然后包装对象消失
	String.prototype.liuzx=function(){
		alert('所有string类型和String对象都可以调用这个');
	}
	var s1 = 'phil';
	var s2 = new String('aaa');
	s1.liuzx();		//弹'所有...'
	s2.liuzx();		//弹'所有...'

	var str='Dunphy';
	str.abc=123;
	alert(str.abc);	//undefined




-----------------数据类型之 引用类型-----------------

	var a = {name: 'Phil'};
	var b = a;
	b.name = 'Alex';
	alert(a.name);	//Alex

	var a = [1, 2, 3];
	var b = a;
	b.push(4);
	alert(a);	//1,2,3,4

	var a = [1, 2, 3];
	var b = a;
	b = [1, 2, 3, 4];
	alert(a);			//1,2,3

	var a=[1,2,3];
	var b=[1,2,3];
	alert(a==b);	//false


复制数组（浅拷贝）：对arr2和arr3的操作不影响arr
	var arr=[1,2,3];
	var arr2=arr.concat([]);
	var arr3=arr.slice(0,arr.length);




-----------------判断类型-----------------

1 typeof:返回类型是string，可能的值有5+1 
	缺点：[]、Date等object无法细分

2 constructor属性：返回实例化对象的构造函数
	number boolean string类型也可以用constructor，是因为调用了包装对象
	null和undefined没有包装类型，使用.constructor会报错

3 instanceof：是否在一条原型链上
	var a = [1, 3, 'a'];
	a instanceof Array; 	//true
	a instanceof Object;	//true，因为Object是最高级父类
	a instanceof Date;		//false

	var str="haha";
	str instanceof String 	//false i

	var str=new String("haha");
	str instanceof String 	//true


题：判断变量a是不是数组的方法？
	1 a.constructor===Array
	2 a instanceof Array




--------------------运算符--------------------
1 typeof

2 instanceof
	a instanceof Aaa
	是否在一条原型链上

3 in：
	'name' in a1
	测试a1中是否存在属性'name'
	(可以是自己的，也可以是顺着原型链找到的)




---------------object的复制---------------
1 浅拷贝：
	for(var attr in a){
		b[attr] = a[attr];
	}
	如果b[attr]是对象，那么a[attr]和b[attr]还是相互影响。

2 深拷贝：
	var a = {
		name : { age : 100 }
	};
	var str = JSON.stringify(a);
	var b = JSON.parse(str);
	b.name.age = 200;
	alert(a.name.age);

3 jQuery的$.extend：将多个对象的内容合并到第一个对象
	$.extend( [deep], target, object1, object2..)
	
  	var b = {};
  	$.extend(true,b,a);	// 深拷贝

	http://blog.csdn.net/fengsuiyingdong/article/details/62225645





-----------------------
   *浮点数使用注意*
JS中的所有数据都是以 64 位浮点型数据(float) 来存储。
所有的编程语言,包括 JS,对浮点型数据的精确度都很难确定：
   var a = 0.1,b = 0.2;
   var c = a + b;
   console.log(c);         //0.30000000000000004
   console.log(c == 0.3);  //false

涉及到小数，要注意：0.07*100!==7   //true	
   parseInt：
      parseInt(0.07*100);  //7
      parseInt(0.57*100);  //56，失败
      parseInt(0.29*100);  //28，失败
   Math.round：
      Math.round(0.57*100);//57
      Math.round(0.27*100);//27
      Math.round(0.07*100);//7


toFixed(n)：四舍五入为n位小数
	var n=9.99999;
	var s=n.toFixed(2);		//"10.00"




-----------------------
	*函数定义*	
1 函数声明：function myFunction() {}
  函数声明不是一个可执行语句,所以：
  	1 因为分号用来分隔可执行语句,所以函数声明不以分号结束
  	2 不会改变变量
		var a = 3;
		function a() {}
		a(); 	//报错
			
2 函数表达式
	var x = function() {};
	console.log(typeof x);	//function
	x();
	实际上是将一个匿名函数存储在x中

3 自调用函数
  通过添加括号,来说明它是一个函数表达式，如果表达式后面紧跟 () ,则会自动调用。
  例子：
  	(function fn(a,b) {
  	   console.log(a*b);
  	})(5,6);

4 函数是对象
	有属性和方法，比如length(形参的数量)、call和apply。

5 函数如果用于创建新的对象,称之为构造函数。




-----------------------
	*函数调用*
不同方式调用，this的值不同。
【注意】不能通过 this=xxx 来修改this的值

1 作为函数调用：this -> window
	sayHi();
	oDiv.onclick = function() {
		sayHi();
	};
	<div onclick="sayHi();"></div>
	sayHi不属于任何对象。但ECMAScript中将window设定为最顶级对象，所有的全局变量都是它的属性和方法。所以sayHi()等价于window.sayHi()


2 作为对象的方法调用：this的值为对象本身
	var Person = {
	    sayHi: function(){}
	}
	Person.sayHi();		//this指向Person对象

	oDiv.onclick = fn1;	//this指向oDiv


3 作为构造函数调用函数
  构造函数中的this没有任何的值，用它来new对象的时候才有
	function myFunction(name) {
	    this.name = name;
	}
	var x = new myFunction("John");	


4 作为函数方法调用函数:call apply
  两个方法的第一个参数都是用来修改this的对象，区别在于之后的参数。
	  1 apply传入的是一个参数数组
	  2 call传入参数（从第二个参数开始）

	function myFunction(a, b) {
	    return a * b;
	}
	myObj1 = myFunction.apply(myObj, [10, 2]); 	//返回20
	myObj2 = myFunction.call(myObj, 5, 7); 		//返回35





-----------------作用域-----------------
1 var和function的变量提升：函数和变量声明会被解释器悄悄地“提升”到方法体的最顶部。
	先提升var，值为undefined。
	再提升function，值为function(){内容}
	提升时重名的话，只留一个

2 ECMA5只有两种作用域:全局、函数作用域

3 只有var和function会提升，ES6中的let和const都不会提升。



-------------------函数参数-------------------
1 默认参数
	a = a || 5;	(当实参a=0时，a也会变为5)
	a = (a !== undefined ? a : 5);	
	ECMA6支持默认参数：function myFunction(x, y=5) {}

2 传递参数：
	如果实参是引用类型：在函数的内部修改对象的属性，会影响外部的全局变量

3 函数.length：形参的数量



-----------------闭包-----------------

闭包：可访问上一层函数作用域里变量的函数,即便上一层函数已经关闭。

	var add = (function () {
	    var counter = 0;
	    return function () {
	    	counter++;
	    	return counter;};
    })();

	add();
	add();
	add();	// 3

实例解析：
	自我调用函数只执行一次：设置计数器为 0，并返回函数表达式
	counter受自我调用函数的作用域保护，只能通过 add 方法修改。





--------------JSON对象--------------
1 stringify
   var arr = [1, 2, 3];
   var j = {
      left: 100
   };
   console.log(JSON.stringify(arr));	//[1,2,3]
   console.log(JSON.stringify(j));		//{"left":100}

2 parse：
   var s1 = '[100,200,300]';
   var a1 = JSON.parse(s1);
   console.log(a1[0]); 		//100

   非常严格，key必须被双引号括起来
   var s2 = '{"left":100}';
   var a2 = JSON.parse(s2);
   console.log(a2.left); 	//100




---------------错误处理---------------
	try {
		throw new Error('抛个错误');
	} catch (err) {
	   console.log(err);
	}




---------------HTML加载---------------

加载:根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）

解析:对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（比如HTML的DOM树，JS的对象属性表，CSS的样式规则等等）

渲染:构建渲染树，对各个元素进行位置计算、样式计算等等，然后根据渲染树对页面进行渲染（可以理解为“画”元素）

这几个过程不是完全孤立的，会有交叉，比如HTML加载后就会进行解析，然后拉取HTML中指定的CSS、JS等。




-------------------随机产生10个从0 ~ 99之间不重复的整数-------------------

   function a() {
       var arr=[0,1,2,3,4,...,99];
       var res=[];
       for(var i=0;i<10;i++){
           var index=Math.floor(Math.random()*arr.length);
           res.push(arr.splice(index,1)[0]);
       }
       return res;
   }



-----------------------
	*一些math函数*
Math.floor()
Math.abs()
Math.ceil()
Math.round()

Math.random()：伪随机小数，范围[0,1)
	0~1:
	   Math.round( Math.random() );
	0~10
	   Math.round( Math.random()*10 );
	20~100
	   Math.round( Math.random()*80 + 20 ) ;
	x ~ y
	   Math.round( Math.random()*(y-x) + x ) ;
	0~x
	   Math.round( Math.random()*x ) ;
	1~x
	   Math.ceil( Math.random() * x);
	   备:上式有可能取到0(当Math.random()恰好=0时),though几率很小

Math.pow(a,b)：a^b(b可以为小数、负数)
Math.sqrt(x)：开平方




----------------------Date----------------------
1 new Date();					//参数为空时，返回当前系统时间
  new Date(2017,3,18,23,3,0);	//2017-4-18-23:03:00 注意月份0-11
 
2 function now() {
	var myTime = new Date();
	var iYear = myTime.getFullYear();
	var iMonth = myTime.getMonth() + 1;	//月份0-11
	var iDate = myTime.getDate();
	var iWeek = myTime.getDay();		//星期0-6
	var iHours = myTime.getHours();
	var iMin = myTime.getMinutes();
	var iSec = myTime.getSeconds();
	iWeek = '星期' + '日一二三四五六' [iWeek];
	var str = iYear+'年'+toTwo(iMonth)+'月'+toTwo(iDate)+'日'+iWeek+''+toTwo(iHours)+':'+toTwo(iMin)+':'+toTwo(iSec);
	return str;
	//统一格式，3s显示03s
	function toTwo(n) {
		return n < 10 ? '0' + n:'' + n;
	}
}

3 两个Date可以相减,结果是number,以ms为单位

	var time1 = new Date(2017, 3, 18, 23, 3, 0); 
	var time2 = new Date();
	var t = Math.floor((time2-time1)/1000);	//将ms转为s，同时转成整数

  再进一步,转为天-小时-分-秒:
	天:Math.floor(t/86400)
	时:Math.floor(t%86400/3600)
	分:Math.floor(t%3600/60)
	秒:t%60

  综合起来：
	var str = Math.floor(t/86400) + '天' + Math.floor(t%86400/3600) + '时' 
			+ Math.floor(t%86400%3600/60) + '分' + t%60 + '秒';




-----------------设置css值-----------------
obj.style.属性：
	obj.style.width='100px';

	针对行间样式。因为行间样式的优先级最高，所以设置的时候很好用

	但是读的时候不好用（css文件和<style>中的样式都读不到）



-----------------读取css值-----------------
方法一:getComputedStyle(obj).width【只读,不能写】
	1:IE8-没有这个函数，会报错
	2:可以获取伪类window.getComputedStyle("元素", "伪类");
	3:得到计算后的值,比如2em经过计算会得到对应的px

方法二:obj.currentStyle.width【只读,不能写】
	1:只有IE能用
	2:不能获取伪类
	3:不会计算,2em还是2em

兼容:
	1 var oStyle = oSpan.currentStyle? oSpan.currentStyle:getComputedStyle(oSpan);	
	2 var oStyle = window.getComputedStyle ? getComputedStyle(oSpan) : oSpan.currentStyle;
		判断条件必须写成window.getComputedStyle，如果省略window.那么在IE8-会报错
	3 问题：方法1 2虽然能解决兼容问题，但是返回的值有可能不同。比如一个div设置width: 20%; 用getComputedStyle()得到的oStyle是270px，用currentStyle得到的oStyle是20%. 

注意:
	1 不能用-,用驼峰:backgroundColor来替代background-color
	2 不要获取复合样式,各浏览器返回不同。
		如background: chrome会返回一长串,FF和IE9+会返回空,IE8-返回undefined
	3 不要用返回的color做判断，各浏览器返回不同。
		black rgb(0,0,0) #000000
	4 不要获取没有显示设置的值
		比如一个div没有设置margin：想要返回margin值:chrome返回0px,FF和IE9+返回空,IE8-返回auto




------------------js操作float样式------------------
float是js中的保留字
IE使用styleFloat,非IE用cssFloat。

1 读：兼容所有
	var oStyle = oSpan.currentStyle?oSpan.currentStyle.styleFloat:getComputedStyle(oSpan).cssFloat;

2 写：要修改float的时候
	obj.style.cssFloat ="left";		// 非IE
	obj.style.styleFloat ="left";	// IE



----------------------
	*if条件的真假*
真:
	非0的数字
	非空字符串
	true
	存在的函数
	存在的对象
假:
	0和NaN
	空字符串''
	false
	不存在的函数
	不存在的对象和null
	undefined
易错：空数组是true，空字符串是false



-------------------- 与&& 或|| --------------------

	var a = 12 < 90 && 20;	// 20
	var a = 12 > 90 && 20;	// false
	var a = 5 > 10 || 7;	// 7
	var a = 5 < 10 || 7;	// true

	var a = 0 || 1 || 2;	// 1
	var b = 1 || 0 || 3;	// 1
	var c = 0 || 0 || 0;	// 0

	var a = 0 && 1 && 2;	// 0
	var b = 1 && 0 && 3;	// 0
	var c = 0 && 0 && 0;	// 0


使用回调函数时:endFn&&endFn();

题目：不用if和switch
	若a=1,则b=15;
	若a=2,则b=37;
	a=其它，则b=69

	var b = ( a===1&&15) || (a===2&&37) || 69 );

	var b = ({'1':15,'2':37}[a] || 69)



-------------------switch-------------------
switch使用恒等===来比较




-----------------------
	*关键字 保留字*
关键字：var function等

保留字：为以后JS扩展用的
	class => className
	float => styleFloat cssFloat



-----------------------
	*连续赋值*
赋值运算符：从右向左 
	a=b=5;相当于a=(b=5)，而b=5返回b

例子1：
 	function f(){  
 	    var a = b = 5;	//只声明了a
 	}
 	alert(a); 	//报错
 	alert(b); 	//报错
 	f();  
 	alert(a); 	//报错
 	alert(b); 	//5
  分析：跟连续赋值的“奥秘”没关系。f()中的b在赋值前没有声明,被提升为全局变量。

例子2：【难点】
	var a = {n:1};  
	var b = a;
	a.x = a = {n:2};  
	alert(a.x);		//undefined
	alert(b.x);		//[object Object]
	a.n="haha";
	alert(b.x.n);	//haha
  关键点：
	运算符.的优先级比=的优先级高
	所以在赋值前,先进行a.x,即给a新加一个属性x,x为undefined	

例子3：
	var a = {n:1};  
	var b = a;
	a = a.x = {n:2};  
	alert(a.x);		//undefined
	alert(b.x);		//[object Object]
  结果和例2一样





-----------------------
	*分号*
在JS中,分号是可选的。如果是一个不完整的语句,JS 将尝试读取第二行的语句。如果读到一个完整的语句,
JS 将自动关闭语句。

看一个例子：
	function myFunction(a) {
	1 	var
	2 	power = 10;  
	3 	return
	4 	a * power;
	}
读到第1行时,var是一个不完整的语句,JS将尝试读取第2行：power = 10。
读到第3行时,由于只有一个return也是完整的语句,所以JS将自动关闭语句:return;。
所以不会读到第4行,在第3行时就返回undefined



--------------------void--------------------
void：计算一个表达式，但是不返回值。

例子：
	var a, b, c;
	a = void(b = 5, c = 7);
	console.log(a);	//undefined

href="#"与href="javascript:void(0)"的区别：
	# 包含了一个位置信息,默认的锚是网页的上端。
	而javascript:void(0), 仅仅表示一个死链接。
	在页面很长的时候会使用 # 来定位页面的具体位置,格式为：# + id。
	如果你要定义一个死链接请使用 javascript:void(0) 。




-----------------------<script>-----------------------

有多个<script>时,从上到下依次处理。处理完一个,才去处理下一个。
所以,使用js库时,要把工具js写在前面,使用写在后面:
	<script src='jquery.js'></script>
	<script> ...使用jquery </script>

例子1:
	<script> var a=33; </script>
	<script> alert(a); </script>	//33

例子2:
	<script> alert(a); </script>	//ReferenceError: a is not defined		
	<script> var a=33; </script>



-------------自动类型转换之 转成string-------------
用toString

1 alert()里面的非字符串内容

2 运算符+
	200 + '3'	//"2003"
	备注：算术运算符里只有+特殊，是转成string。其他运算符都是转成number。这是因为只有+有两重作用：加法和连接字符串。




-------------自动类型转换之 转成数字-------------
用Number

1 -*/%
	'200' * 3   	结果：600  
	'…'-9       	结果：NaN,因为Number('…')->NaN，NaN-9还是NaN

2 ++ --
	var a='5';
	a++				结果：6

3 > <
	'100'>9       	结果：true,转num
	'100'>'9'     	结果：false,不转num
	'100px' > 9  	结果：false NaN和9不能比较大小，只能说不等 
	'100px' !== 9  	结果：true





---------------转数字---------------
Number() parseInt() parseFloat()

1 Number():隐式类型转换中需要转换成数字的，都是自动调用Number()
	Number('+100')	//100

2 parseInt()：忽略开始的空白符，读到非数字时停
	parseInt(' 3.59px');		//3
	parseInt('  a3.59');		//NaN

例子：        Number  parseInt parseFloat
  a='    '		0		NaN 	NaN
  a=true		1		NaN 	NaN
  a=[3.5]		3.5		3 		3.5
  a=[3.5,5]		NaN		3 		3.5
  a=null		0		NaN 	NaN
  a=' 2.9px 2'	NaN		2 		2.9
  a={}			NaN 	NaN 	NaN
  a=undefined 	NaN 	NaN 	NaN



进制转换：
	parseInt(num,num的进制x)：将x进制转成10进制
	num.toString(进制)：将10进制转成x进制



-----------------------NaN-----------------------
NaN：not a number

1 var a = Number('abc');	// NaN
  typeof (a) ;	// NaN的类型是number

2 一旦写程序中出现:NaN  肯定进行了非法的运算操作
	alert( '200px' -  100 );

3 NaN是false

4 NaN和自己不相等：
	console.log(NaN === NaN);	//false
	console.log(NaN == NaN);	//false
	console.log(undefined === undefined);	//true
	console.log(null === null);	//true

isNaN()函数：判断是不是数字(不是判断数字类型)
	会自动先用Number()进行转换

isNaN(function(){});//不是num->true
isNaN('250');		//Number('250')=250->是num->false
isNaN([])			//Number([])=0->是num->false




-----------------------定时器-----------------------
1 异步

2 先计时：第一次函数执行前，也要先等xx毫秒


	var timer1 = setInterval( 函数, 毫秒，参数);	//重复执行
	clearInterval(timer1);
	var timer2 = setTimeout( 函数, 毫秒，参数 );	//执行一次
	clearTimeout(timer2);

注意：如果要开关多次定时器，那么开之前，一定要先关


定时器的第一个参数可以是字符串形式的函数语句：
	var num = 0;
	function fn1(n) {
	    console.log(n);
	}
	setInterval("num++;fn1(num);", 1000);


【兼容性】IE10-不支持定时器传参





--------------------DOM--------------------
DOM:document object model 文档对象模型
	标准：W3C标准
	顶级对象：document
 
浏览器会根据DOM模型,将HTML文档解析成一系列的节点,再由这些节点组成一个树状结构。
DOM的最小组成单位叫做节点(node),节点有12种。（元素节点的nodeType为1）

一般地,节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。
节点类型不同,这三个属性的值也不相同



------------
DOM：创建、添加、替换、删除、克隆------------

1 创建：document.createElement(标签名称);
	1 什么都可以动态创建：link script style..
	2 标签名字叫什么都ok。
	3 创建完的标签浏览器就认得了，HTML5新标签兼容就是这么解决的

2 添加：         
	1 父级.appendChild(要添加的元素)
		加在最后面
	2 父级.insertBefore(新元素,指定元素)	
		在指定元素前面插入新元素
		第二个参数的节点不存在时，会以appendChild的形式进行添加
        (IE8-下如果第二个参数的节点不存在,会报错)

3 替换：父级.replaceChild(新节点,被替换节点)

【注意】appendChild,insertBefore,replaceChild都可以操作动态创建出来的节点,也可以操作已有节点。而且是将已有的元素移动，而不是复制一份进行操作。

4 克隆：var cElement=元素.cloneNode(true); 
	默认false：只克隆元素本身
	true：克隆克隆元素和其所有子节点。
	注：事件是不会被克隆的

5 删除：父级.removeChild(要删除的元素);





--------------------DOM: 找所有子节点--------------------
两种方法：childNodes和children，都是：
	1 只找子节点,不找孙节点
	2 只读属性，返回子节点列表的集合

第一种：childNodes【不推荐】
	标准：会包含所有类型的节点（12种）	
	IE8-：只包含元素节点

第二种：children【推荐】	
  1 标准+非标准：都是只包含元素节点
  2 例子：
	for (let i = 0; i < oUl.children.length; i++) {
		oUl.children[i].style.background = 'red';
	}



--------------------DOM: 找特定子节点--------------------

标准(IE9+)：
  1 找元素子节点
	父.firstElementChild
	父.lastElementChild
	子.nextElementSibling
	子.previousElementSibling
  2 找子节点（包含所有类型节点）
 	父.firstChild
 	父.lastChild
 	子.nextSibling
 	子.previousSibling

IE8-：只能找到元素节点（没有firstElementChild等属性）
	父.firstChild（找到第一个元素子节点）
	父.lastChild
	子.nextSibling
	子.previousSibling




-----------------DOM: 找父节点-----------------
1 元素.parentNode

2 元素.offsetParent:找到定位父级
	如果没有定位父级,默认是body（不是document）
	document.body.offsetParent===null(说明body没有offsetParent)




--------------offsetLeft和offsetTop--------------

元素.offsetLeft:只读 
  当前元素外边框到定位父级的内边框的距离
  如果没有定位父级,offsetLeft是到document的距离




--------------getBoundingClientRect--------------
	getBoundingClientRect
用法：oDiv.getBoundingClientRect().left
	获取某个元素的信息（left,top,bottom,right）
	元素的外边框到当前窗口边框的距离

兼容IE8






--------------------操作属性--------------------

都是针对行间属性的：
	<div id="div1" aaa="124"></div>
1 获取	elem.getAttribute('id')	
2 设置	elem.setAttribute('bbb','157') 这样设置DOM中可以看到
3 删除	elem.removeAttribute('aaa')

特点：
	1 想要在js中给elem添加行间的自定义属性，就需要用elem.setAttribute('index','aaa')
	  用elem.index='aaa'设置的不是行间的，在DOM中看不到

	2 getAttribute可以获取src href的相对地址，可以来做判断
		img.src 返回的是绝对地址，而且不同浏览器格式可能不同
		if(oImg.getAttribute('src') == '1.jpg') 可以
		if(oImg.src == '1.jpg') 不可以






-----------------元素宽高-----------------
1 style.width : 样式宽   有单位 w
2 clientWidth : 可视区宽 无单位 w+p
3 offsetWidth : 占位宽   无单位 w+p+b

其中style.width只能操作行间，读写都行。
clientWidth和offsetWidth能读取任意位置的结果，但是只读，不可写。






--------------------JS组成--------------------
1 JS组成：ECMAScript + DOM + BOM
	ECMAScript 	
	DOM接口		document 	遵从W3C标准
	BOM接口		window   	各浏览器自己的标准

2 window对象的双重身份
	1 window是BOM的顶层对象，特指【当前】窗口
	2 window不是JS对象。但是在ECMAScript中将window设定为Global对象，所以全局变量、全局函数都是window的属性和方法
	3 所以，window中的内容，有的是因为BOM，有的是因为ECMASctipt 。
		window.open()		//BOM中定义的open方法
		window.document 	//因为ECMAScript将window定为全局变量




--------------------BOM--------------------

顶层对象：window，指【当前】窗口。

Window对象的：
	1 方法：open close alert confirm prompt
		1 open(url,打开方式)
			返回新开页面的Window对象
			url默认是空白页面,打开方式默认新窗口

		2 close方法：可以关闭本窗口中用window.open方法打开的新窗口
			opener.close(); 

		3 alert confirm prompt
			var a = window.alert('这是警示框');     //undefined
			var c = window.confirm('你确认吗?');    //true或者false
			var p = window.prompt('输入信息');  	//返回一个string或null

	2 属性：
		1 navigator.userAgent 是string
		2 location: 是object
			location.href
		   	location.search = url?后面的内容
		   	location.hash = url#后面的内容
		   	......

	3 常用事件
		1 onscroll
		2 onresize

注：很多情况下，新窗口有“跨域”问题，出于安全考虑，很多属性、方法不允许操作





--------------------窗口的大小--------------------

1 可视区尺寸 可读 不可写（是number类型）
	document.documentElement.clientWidth/clientHeight	

2 滚动条滚动距离：可读 可写（是number类型）
	document.body.scrollTop/scrollLeft
	document.documentElement.scrollTop/scrollLeft
	其他所有浏览器：body的恒为0  documentElement的是所要
	只有chrome是：	body的是所要 documentElement的恒为0
	兼容：
		var doc = document[document.body.scrollTop ? 'body' : 'documentElement'];
	可读：alert(doc.scrollTop);
	可写：doc.scrollTop = 500;

3 文档高度 （是number类型）
	document.body.offsetHeight





--------------------事件对象event--------------------
1 event事件对象
  当一个事件发生的时候，这个事件的详细信息会被保存到event对象中
  event对象必须在一个事件函数中才有内容

2 事件函数：
  一个函数是不是事件函数,不在定义时决定,而是在函数调用时决定。		
  例子：
	fn1();					//不是事件函数
	document.onclick = fn1;	//是事件函数

3 兼容性：	
	1 ie8-：event是一个内置全局对象,可以直接用
	2 标准：事件对象是通过事件函数的第一个参数传入
  	兼容：
	  	function fn1(ev) {
	  		ev = ev||window.event;
	  	}

4 clientX[Y]属性:当一个事件发生的时候,鼠标到页面可视区的距离	
  例：跟随鼠标移动的div
	document.onmousemove = function(ev) {
		// oDiv是fixed的	
		ev = ev || event;
		oDiv.style.left = ev.clientX +'px';
		oDiv.style.top = ev.clientY + 'px';
	};




---------------事件绑定/取消的2种方式---------------
oDiv1.onclick = fn1;  
"给oDiv1的click事件的冒泡阶段添加事件处理函数fn1"：告诉div1,如果它接收到了一个点击事件,那么它在冒泡阶段就去执行fn1

（一）一个事件只能绑定一个函数
	obj.onclick = fn1;
	obj.onclick = fn2;	//fn2会覆盖前面绑定的fn1	
	1 没有捕获，只能冒泡。阻止冒泡用：
		ev.cancelBubble = true;
		ev.stopPropagation&&ev.stopPropagation();
	2 阻止默认事件：
		return false
	3 取消绑定：
		obj.onclick = null;

（二）一个事件可以绑定多个函数
	1 obj.attachEvent('onclick', fn1);
	  obj.attachEvent('onclick', fn2);
	  obj.detachEvent('onclick', fn1); //fn2还在
	  	1 IE10-(经测试IE edge中不可用)
	  	2 没有捕获，只能冒泡，阻止冒泡：
	  		ev.cancelBubble=true;
	  	3 this指向window，解决：
			obj.attachEvent('onclick', function() {
				fn1.call(obj);
			});
	  	5 阻止默认事件：
	  		return false
	  	6 取消绑定：
	  		detachEvent

	2 obj.addEventListener('click', fn1, false);
	  obj.removeEventListener('click', fn1, true);	//没取消上面的
	  obj.removeEventListener('click', fn1, false);	//这才取消了
		1 标准(IE8-不支持)
		2 true捕获 false冒泡。默认为false
		3 阻止默认事件：
			preventDefault()
		4 取消绑定：
			removeEventListener





--------------------冒泡与捕获--------------------
更多参考：http://blog.jobbole.com/39446/
1 问题：里外层div都绑定了事件，点击里层div后，哪个事件先触发
	<div>
	    <div></div>
	</div>

2 历史回顾
	Netscape主张：外层优先 捕获
	微软主张：内层优先 冒泡

3 W3C规范：先进入捕获阶段，直到达到目标元素，再进入冒泡阶段
	捕获阶段：外->里
		标准：addEventListener( , , true);
	冒泡阶段：里->外
		obj.onclick = fn;
		IE：attachEvent
		标准：addEventListener( , , false);




--------------------默认事件--------------------

1 默认事件：浏览器默认做的事情。比如：
	点击一个a链接：跳转到对应页面
	点击form内的submit：向后端提交数据
	在一段文字上点击并移动鼠标：选中文字
	js中运行到oBtn.focus()：光标移到oBtn中
	右键单击：弹出右键菜单
	按空格：页面下滚
	鼠标滚轮：页面滚动

2 怎么阻止？
	1 首先确定当前这个行为是什么事件触发的，
	  然后在这个事件的处理函数中阻止它
	2 具体方法
		obj.onclick = fn和attachEvent：return false
		addEventListener：ev.preventDefault()

例子1：阻止右键菜单
	document.oncontextmenu = function() {
		return false;
	};
	document.attachEvent('oncontextmenu', function() {
		return false;
	});
	document.addEventListener('contextmenu', function(ev) {
		ev.preventDefault();
	});

例子2：阻止了keydown的所有默认事件，比如：页面有滚动条时，按space不会下滚了。
	document.onkeydown = function() {return false;};





--------------------键盘事件--------------------
首先要注意：不是所有元素都能够接收键盘事件。能够响应用户输入的元素，能够接收焦点的元素才能够接收键盘事件。所以oDiv.onkeydown=..是没有用的。

键盘事件：keypress keydown keyup
	keypress:字母数字键(大小写一个值，大小键盘的数值一个值)
	keydown/up:所有键（字母数字键+功能键）
	触发顺序：down - press - up

1) keydown事件：按下时触发。如果按下不抬起，那么会连续触发。
2) keyup事件：抬起时触发
3) 属性：
	1 event.keyCode : 是number类型。
	  键盘按键的值，简称‘键值’。是对应的ASCII码，比如按下字母a，返回的是a的ASCII码。相同按键的键值一样，左CTRL和右CTRL的值一样

	2 event.ctrlKey,shiftKey,altKey:是boolean类型
	  当一个事件（不一定是键盘事件）发生的时候，如果ctrl、shift、alt 是按下的状态，返回true，否则返回false

例子1：ctrl+回车留言  enter的键值是13	
  	oText.onkeyup = function(ev) { //这里用up down press都可以
  		var ev = ev || event;		
  		if ( this.value != '' ) {
  			if (ev.keyCode == 13 && ev.ctrlKey) {
  				var oLi = document.createElement('li');
  				oLi.innerHTML = this.value;
  				oUl.appendChild( oLi );
  			}			
  		}		
  	};


例子2：键盘控制div移动
	注意普通div是不能接收键盘事件的
  	document.onkeydown = function(ev) {	
  		switch(ev.keyCode) {
  			case 37:	//左
  				oDiv.style.left = oDiv.offsetLeft - 10 + 'px';
  				return false;//只有上下左右阻止了默认事件
  			case 38:	//上
  				oDiv.style.top = oDiv.offsetTop - 10 + 'px';
  				return false;
  			case 39:	//右
  				oDiv.style.left = oDiv.offsetLeft + 10 + 'px';
  				return false;
  			case 40:	//下
  				oDiv.style.top = oDiv.offsetTop + 10 + 'px';
  				return false;
  		}
  		//return false; //阻止所有keydown默认事件,包括F5刷新、空格下滚等
  		
  	}
   注意：onkeydown如果按下不抬起，那么会连续触发。但是【连续按的时候，接受第一个响应之后会停一下，是计算机设计中人性化的考虑：害怕使用者不小心按久了一点。所以上面这么写，每次重新按都会“傻”一下，解决方法见“各种小效果 031”






--------------------
	*cookie*
cookie是http协议制定的。由服务器把cookie保存到浏览器，浏览器进行下一次请求时，把上次从服务器得到的cookie再归还给服务器。
javaWeb中使用cookie：
	response.addCookie()
	request.getCookies()

cookie : 存储数据，当用户访问了某网站（网页）的时候，可以通过cookie在访问者的电脑上存储数据。可以设置存储时长。
    1.不同的浏览器存放的cookie位置不一样（存在用户电脑中的不同位置），所以是不能通用的
    2.cookie的存储是以域名区分的，不同域名的网站存在不同位置（文件夹）中
    3.存放cookie的个数、内容大小有限制
    
1 写：
	document.cookie = 'username=emily';
	document.cookie = 'age=8';

2 读：
	我们通过document.cookie来获取当前网站下的cookie的时候，得到的字符串形式的值，他包含了当前网站下所有的cookie。他会把所有的cookie通过"分号+空格"的形式串联起来
	alert(document.cookie)	//"username=emily; age=8"

3 存储时长：
  cookie默认是临时存储的，当浏览器关闭进程的时候失效
  可以给cookie设置过期的时间：document.cookie = '名称=值;expires=时间';
  时间必须是字符串格式的，用函数 toUTCString()：可根据世界时 (UTC) 把 Date 对象转换为字符串,并返回结果。  

4 内容用编码存放、读取（避免特殊字符有的浏览器存储出问题,如\n换行符） 
	encodeURI	decodeURI
	存：document.cookie = 'username=' + encodeURI('emily\n你好');
   	读：alert(decodeURI(document.cookie));




----------------问题：子级影响父级----------------
例子：
	<style>
		#div1 {width: 200px;height: 200px;background: red;}
		#div2 {width: 100px;height: 100px;background: yellow;}
	</style> 
	<body>
	    <div id="div1">
	        <div id="div2"></div>
	    </div>
	</body>
    <script>
	    var oDiv = document.getElementById('div1');
	    oDiv.onmouseover = function() {document.title += '1';};
		oDiv.onmouseout = function() {document.title += '2';};
    </script>
    
1 鼠标从"oDiv外界空白"移到"内层div2"时：
	效果：title加上"1"
	原因：冒泡
2 鼠标从"内层div2"移到"oDiv外界空白"时：
	效果：title加上"2"
	原因：冒泡
3 鼠标从"外层oDiv"移到"内层div2"时：
	效果：title加上'21'
	原因：鼠标离开外层oDiv了，所以title加"2"
		  内层div2的"鼠标进入事件"冒泡到外层oDiv，所以title加"1"
所以纯“阻止冒泡”不能解决问题
	给内层div2的mouseover和mouseout都阻止冒泡
	对情况3：title不会加1了，但还是会加2

解决：onmouseenter onmouseleave(子级不会影响到父级)




-----------Image-----------
<img> 标签每出现一次，一个Image对象就会被创建。
常用事件；onload onerror	
canvas中加载图片：
	var myPic=new Image();
	myPic.onload=function(){
		ctx.drawImage(this,0,0);
	};
	myPic.src='1.jpg';

