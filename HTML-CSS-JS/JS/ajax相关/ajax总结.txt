


-----------
	*第一个ajax程序*
备注：所有ajax测试都必须在服务器环境中（localhost），直接打开本地文件来测试无效。	
	oBtn.onclick = function() {

	   //创建对象
	   var xhr = new XMLHttpRequest();

	   //open方法，参数：打开方式、地址、是否异步
	   xhr.open('get', '1.txt', true);

	   //上面都是准备工作，send才是发送请求
	   xhr.send();

	   //等待服务器返回内容
	   	xhr.onreadystatechange = function() {
		   	if (xhr.readyState == 4) {
	          	if (xhr.status == 200) {
	             	alert(xhr.responseText);
	          	} else {
	             	alert('出错了,Err：' + xhr.status);
	          	}
	        }
	   	};

	};
只是个结构实例，没干什么有用的。下面解释具体的



-----------
	*等待服务器返回内容*
1 readyState属性：请求状态 是number类型
	0（初始化）还没有调用open()方法
	1（载入）已调用send()方法，正在发送请求
	2（载入完成）send()方法完成，已收到全部响应内容
	3（解析）正在解析响应内容
	4（完成）响应内容解析完成，可以在客户端调用了

2 onreadystatechange事件 : 当readyState改变的时候触发 

3 responseText：ajax请求返回的内容，以文本形式存放，是string类型

4 status : http状态码
	200 请求成功



-----------
	*发送数据：get的2个问题*
get方式：数据名称和值用=连接，多个数据组用&进行连接，然后把数据放到url?后面传到指定页面。

问题1：缓存
缓存会以整体存（包括url和url？后面的所有内容）。如果整体名字不变，有缓存的时候它就会用缓存，后端文件更新了它也不会去读最新的。
解决方法：让url?后面的内容每次都不一样，浏览器就没法去读缓存了。在url？后面连接一个随机数，时间戳
  
问题2：中文乱码
解决方法：编码encodeURI

	xhr.open('get', '2.get.php?username=' + '刘伟' + '&age=30&', true);
	xhr.open('get', '2.get.php?username=' + '刘伟' + '&age=30&' + new Date().getTime(), true);
	xhr.open('get', '2.get.php?username=' + encodeURI('刘伟') + '&age=30&' + new Date().getTime(), true);

备注：getTime() 方法可返回距1970年1月1日之间的毫秒数。是number类型



-----------
	*发送数据：post的注意事项*
post方式，数据放在send()里面作为参数传递

注意事项：需要声明发送的数据类型
（和form不同，form的enctype有默认值application/x-www-form-urlencoded）

	xhr.open('post','2.post.php',true);
	//申明发送的数据类型
	xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
	xhr.send('username=刘伟&age=30');

post没有缓存问题；不用额外处理中文编码问题（因为urlencoded已经解决了）


-----------
	*JSON对象的2个方法*

1 stringify : 可以把一个对象转成对应字符串
   var arr = [1, 2, 3];
   var j = {
      left: 100
   };
   console.log(JSON.stringify(arr));	//[1,2,3]
   console.log(JSON.stringify(j));		//{"left":100}

2 parse : 可以把字符串转成对应对象
  parse非常严格，key必须被双引号括起来（单引号不行，没有引号更不行）
   var s1 = '[100,200,300]';
   var a1 = JSON.parse(s1);
   console.log(a1[0]); 		//100

   var s2 = '{"left":100}';
   var a2 = JSON.parse(s2);
   console.log(a2.left); 	//100




-----------
	*瀑布流布局*
两种：
  1 列数固定：
  2 列数不固定：根据窗口大小而调整列数
这里只说列数固定的，假设列数为4

总体思路：
  1 用ajax动态添加数据，滚动条不断下拉，才不断加载更多内容
  2 所有内容都是通过ajax从后端获取、添加。最开始（ajax加载数据前），每一列中都没有内容，也就是列高为0。
  3 每一块请求：利用ajax获取数据，然后添加到一列后面appendChild。
  4 因为每块内容高度不确定，为了避免列高度相差太多。所以ajax添加块不是顺序依次加，而是计算列的高度，哪个列最“短”，就往它那加

html结构：
  ul是整体,ul>li是一列,ul>li>div是一块内容
  ul>li>div>img是图片，ul>li>div>p是文字说明
	<ul>
		<li>
		   <div>
		   	  <img>
		      <p></p>
		   </div>
		</li>
		<li></li>
		<li></li>
		<li></li>
	</ul>

注意：
	1 找出height最小的列
	2 由于图片加载有延时，没有把列的高度撑起来
	   解决方法：手动给img设置高度(需要后端支持，提供图片宽高数据)
	   列是固定宽度的，所以在css中设置了图片的width:100%
	   高度也必须设置，因为图片加载需要时间，没加载好时图片高度是0，所以需要自己根据比例算一下高度

	3 滚动时，不断加载内容。
   		加载新内容的条件：最短的那一列的底部，已经出现在可视区里了

	4 滚动加载内容是需要时间的。如果前面一批还没有加载完（列的高度没有被撑开时），又滚动，那么又会触发加载。这样会连着加载很多page。
  		解决：添加全局变量来监控，前一批数据是否全部加载完成

	5 数据全部加载完了，要处理一下
		如果后台返回的data.length==0，则没有数据了，取消滚动事件