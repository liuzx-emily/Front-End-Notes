 兼容性：不支持IE8-，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性（ Object.definedProperty ）


最重要的是思路转换：
1 数据驱动
	去修改数据，让vue自动帮你做其它所有事。
	目标：杜绝DOM操作！
2 组件化



# 一. 渐进式框架

二. vue中的两个核心点
	1 响应的数据绑定
	 	数据改变 -> 自动更新视图
	 	利用Object.definedProperty中的setter/getter代理数据，监控对数据的操作
	 	注意：只有当实例被创建时 data 中存在的属性才是响应式的！！！！

	2 组件


三. 虚拟DOM
	1 操作DOM慢，页面卡
	2 DOM节点可以表示为一个JS对象，也就是虚拟DOM
		var domNode = {
		  tag: 'div'
		  attributes: { id: 'div1' }
		  children: []
		};
	3 操作虚拟DOM快
		domNode.children.push(新的子节点);


----------------计算属性computed、方法methods、监听watch----------------
计算属性computed、方法methods、监听watch可以达到相似的功能

1 计算属性 vs 方法
	每次触发重新渲染时：
		计算属性：基于依赖进行缓存的。只在相关依赖发生改变时才会重新求值。如果依赖没有变化，那么多次访问都会立即返回之前的计算结果，不会执行计算函数。
		方法：每次都会执行函数，重新计算

	举例1：
		computed:{
			// 每次触发重新渲染，不会重新计算，而是返回之前缓存的值
			now(){
				return Date.now();
			}
		}

2 计算属性 vs 监听watch
	一般用计算属性比较好

	举例：将a b求和，得到c的值
		1 计算属性的写法：
			computed:{
				c(){
					return a+b;
				}
			}

		2 监听的写法：
			watch:{
				a(to,from){
					this.c=to+this.b;	
				},
				b(to,from){
					this.c=this.a+to;
				}
			}



----------------
	*模版
1 html模版
2 字符串模版：template字符串
3 模版-render函数


----------------
	*html模版
插值：
	文本："Mustache"语法（双大括号）{{}} 
	v-html
	属性：v-bind:  简写:

例：
	<article>
	    <div>{{lzxMessage1}}</div>
	    <div v-html="lzxHtml"></div>
	    <div :lzx="lzxAttrValue"></div>
	</article>
	<script>
	new Vue({
	    el: "article",
	    data: {
	        lzxMessage1: "银之匙",
	        lzxHtml: '<span>钢之炼金术师</span>',
	        lzxAttrValue: '上校'
	    }
	});
	</script>
  渲染结果：
  	<article>
  	    <div><span>钢之炼金术师</span></div>
  	    <div>银之匙</div>
  	    <div lzx="上校"></div>
  	</article>

----------------
	*字符串模版
模版将会替换挂载的元素。只能有一个根节点
例1：
    <article></article>
    <script>
    new Vue({
        el: "article",
        data: {lzxMessage1: '钢之炼金术师'},
        template: '<span>{{lzxMessage1}}</span>'
    });
    </script>
  渲染结果：
	<span>钢之炼金术师</span>

只有一个页面时，可以将html结构写在script中，设置type="x-template"。多个页面时不能复用，所以不要这么写。
例2：
	<article></article>
	<script type="x-template" id="lzxT">
	    <input type="button" value="吧啦">
	</script>
	<script>
	new Vue({
	    el: "article",
	    data: {
	        lzxMessage1: '钢之炼金术师'
	    },
	    template: '#lzxT'
	});
	</script>
  渲染结果：
  	<input type="button" value="吧啦">

----------------
	*模版-render函数
vue中的createEle函数：
	参数：标签名 [数据对象] 子元素
参数 - 数据对象；
	class:{}
	style:{}
	attrs:{}
	domProps:{} DOM元素属性
	on:{}
例：
	<div id="demo"></div>
	<script>
	new Vue({
	    el: "#demo",
	    render(createEle) {
	        return createEle(
	            "ul", {
	                class: {
	                    pretty: true
	                },
	                style: {
	                    fontSize: '50px',
	                    backgroundColor: '#eee'
	                },
	                attrs: {
	                    lk: "吧嗒"
	                },
	                domProps: {
	                    innerHTML: '<li>我是html，会使下面创建的的子元素无效</li>'
	                }
	            }, [
	                createEle("li", 1),
	                createEle("li", 2)
	            ]
	        );
	    }
	});
	</script>
  渲染结果：
  	<ul lk="吧嗒" class="pretty" style="font-size: 50px; background-color: rgb(238, 238, 238);">
  	    <li>我是html，会使下面创建的的子元素无效</li>
  	</ul>

----------------
	*绑定class
例1：
	<div id="demo">
	    <span class="coral" :class="{gray:addClass2}">钢之炼金术师</span>
	    <br>打勾勾
	    <input type="radio" name="dada" v-model="addClass1" value="true">
	    <br>我才不选呢
	    <input type="radio" name="dada" v-model="addClass1" value="false">
	</div>
	<script>
	var vm = new Vue({
	    el: "#demo",
	    data: {
	        addClass1: "true"
	    },
	    computed: {
	        addClass2() {
	            return this.addClass1 === "true";
	        }
	    }
	});
	</script>
  渲染结果：
  	class coral一直都在。class gray根据radio，可以来回切换


----------------
	*v-for指令：
	根据一组数组的选项列表进行渲染
变异方法：
	vue提供一组方法，对数组进行操作的时候，会触发视图更新。
	这些方式是vue自己实现的，和原生的方法名字相同，API没有变化（为了方便使用）。
	push pop shift unshift splice sort reverse


----------------
	*v-on：监听DOM事件，触发处理函数
事件修饰符：
	.stop  .prevent  .capture  .selft  .once
  按键修饰符：
  	.enter  .tab  .left  .ctrl .键值
  例：
  	v-on:keyup.enter


----------------
	*v-model


----------------
	*
事件处理函数需要传参时，要把数据对象手动地用$event传
v-on:keyup="addTodo(123,$event)"
addTodo(data,ev){}


----------------
	*
条件渲染：v-show 
1. v-show
	<span v-show="list.length">...</span>	list中有东西，才显示span
	元素会被渲染在页面中，只是根据表达式切换css(display：none)
2 v-if

----------------
	*自定义指令
directive
钩子函数 钩子函数的参数

----------------
	*监控watch  
  list:function(){} //是“浅层监控”

  list:{
    handler:function(){},
    deep:true //深度监控
  }

----------------
	*组件
vue中的组件：自定义标签 or 扩展的原生html元素

单文件组件：.vue文件

思路：
	1 先写出html结构和css
	2 找出"可变的"：
		<1> props：简单数据（类型检查 默认值..）
				想传非string类型，必须要用v-bind
		<2> slot ：模版 html结构
	3 交互：自定义事件
		元素.$emit(事件名，参数)

----------------
	*实例 树形菜单
迭代：组件的模版里调用自己
计算迭代层级