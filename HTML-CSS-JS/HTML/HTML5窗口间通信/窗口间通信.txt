窗口间通信：
	1 两个窗口是同域的：iframe window.open
	2 两个窗口是跨域的：postMessage

前后端数据交互：ajax的跨域请求

websocket

HTML5应用程序缓存

web worker多线程

--------------
	*同域时的操作*
可以通过javascript操作新窗口中的内容，需要先获得新页面的window
1 iframe
2 window.open()

--------------
	*同域时的iframe*
1 操作子辈：contentWindow属性
  要操作一个iframe里面的DOM元素，首先要获取到iframe引入的页面的window。
  使用contentWindow属性：iframe包含的页面的window对象

	<iframe src="lzx.html"></iframe>

	var oIframe = document.querySelector('iframe');
	var frameWindow=oIframe.contentWindow;
	frameWindow.document.body.style.backgroundColor='coral';

2 操作父辈：parent top对象
  iframe中的窗口对象
	window：当前窗口。
	parent：父级窗口(没有父级时，就是自己)
	top：顶级窗口(没有顶级时，就是自己)
	对最顶级的对象：window==parent==top
	对次顶级的窗口：parent==top
  所以被包含的iframe页面可以操作包含它的页面
  例：
  	a.html中通过iframe包含2.html窗口
		<iframe src="2.html"></iframe>
  	b.html中的js：
		oBtn.onclick=function(){}
			parent.document.body.style.backgroundColor='coral';
		};
  效果：在a.html的iframe中，点一下b.html的oBtn，a.html就变coral


--------------
	*同域时的window.open*
1 操作子辈：window.open()
  window.open 返回被打开窗口的window对象
	var newWindow = window.open('lzx.html', '_blank');
	newWindow.document.title='hiahia';

2 操作父辈：window.opener属性
  window的opener属性：通过window.open方法打开当前页面的窗口window
  例：
	  a.html中通过window.open打开2.html窗口
		window.open('2.html','_blank');
	  b.html中的js：
		oBtn.onclick=function(){}
			window.opener.document.body.style.backgroundColor='coral';
		};
	  效果：b.html是通过a.html打开的。点击b.html中的oBtn，a.html就变coral


--------------
跨域的测试环境：
	wamp32中搭建虚拟主机
	没成功，遇到问题解决不了：You don't have permission to access /on this server.

--------------
	*跨域时的操作*
跨域时的iframe和window.open还是可以获得新窗口的window对象，但是没有权限操作这个window对象。
下面讲HTML5解决跨域的方法：postMessage方法

--------------
	*postMessage*
实现跨域通信：
  窗口a和窗口b是不同域下的，浏览器不允许a去操作b。利用postMessage当作中间的“信使”，窗口a和b协同合作。
  此时窗口a还是不能直接修改窗口b，只是利用postMessage方法给窗口b发送信息。窗口b在收到a的信息后，进行相应的操作。
  所以窗口b也需要写好js，对a发来的不同消息作出反应。
发送方：使用postMessage
	接收方的window对象.postMessage();
	第一个参数：发送的数据
	第二个参数：接收方的域名（带上协议）
接收方：
	window的message事件：当窗口接收到通过postMessage发送过来的数据的时候触发。message事件的事件对象ev下保存了发送过来的内容
	ev.data : 发送过来的数据
	ev.origin：发送方的域名

例：窗口a：www.a.com域下的1.html
	窗口b：www.b.com域下的1.html
	a给b发信息
  窗口a：
  	<iframe src="http://www.b.com/1.html"></iframe>

	var newWindow=document.querySelector('iframe').contentWindow;
	newWindow.postMessage('hiahia',"http://www.b.com");
  窗口b：
  	window.addEventListener('message',function(ev){
  		//alert(ev.data);	//弹出hiahia
  		//alert(ev.origin);	//弹出http://www.a.com
  		if(ev.data==="hiahia"&&ev.origin==="http://www.a.com"){
  			document.body.style.background='coral';	//窗口b的背景变为coral
  		}
  	},false);

--------------
	*ajax跨域*
html5支持ajax的跨域请求
在标准浏览器下，XMLHttpRequest对象已经是升级版本，支持了更多的特性，可以跨域了。但是，如果想实现跨域请求，还需要另一个域的后端支持：设置header
	
XMLHttpRequest : 增加很多功能，虽然还能用，但是不推荐使用onreadystatechange事件来监听。推荐使用onload。
	onload事件当请求成功时触发，即xhr.readyState == 4时
	
XDomainRequest : IE如果想实现跨域请求，则需要使用这个对象实现(IE7+都可以)

例：域a想要访问域b下的1.php文件
  标准下：
	var xhr=new XMLHttpRequest();
	xhr.onload=function(){
		if(xhr.status==200){
			alert(xhr.responseText);
		}
	}
	xhr.open('get','http://www.b.com/1.php', true);
	xhr.send();
  IE下：
	var oRequest = new XDomainRequest();
	oRequest.onload = function() {
		alert(this.responseText);
	};
	oRequest.open('get', 'http://www.b.com/1.php', true);
	oRequest.send();

  在http://www.b.com/1.php中：
	header('Access-Control-Allow-Origin:http://www.a.com');
	//设置允许访问该资源的域

--------------
	*ajax无刷新上传*
XMLHttpRequest对象的新功能：利用ajax实现，无刷新上传文件。(IE不支持)
1 上传文件要用：	<input type="file">
	var oFile=document.querySelector('[type="file"]');
	oFile.value	//是文件的名字，只是给用户看的
	oFile.files //file控件中选择则的文件列表对象 是类数组（draggable拖拽外部文件也用的files对象）
  如果只上传一个，需要传递：oFile.files[0]


2 使用ajax无刷新上传
	要用post方法，get有大小限制

	var xhr=new XMLHttpRequest();
	xhr.onload=function(){
		if(xhr.status==200){
			alert(this.responseText);
		}
	}
	xhr.open('post','1.php',true);
	//post方法在send前要设置请求头
	xhr.setRequestHeader('X-Request-With','XMLHttpRequest');
	//xhr.send('file='+oFiles.files[0]);//不行
	//不能直接发送oFiles.files[0]，需要利用FormData对象把它转换
	var oFormData=new FormData();
	oFormData.append('file',oFiles.files[0]);//一参：key,二参:value
	xhr.send(oFormData);

3 监听上传进度：upload对象
	事件progress：在上传的过程中连续触发
	ev.total发送总量，ev.loaded待发送的总量
	所以上传进度就是：ev.loaded/ev.total

	var oUp=xhr.upload;
	oUp.onprogress=function(ev){
		var x=ev.loaded/ev.total; //上传进度
		oSpan.innerText=x*100+'%';
	}
总结：
	var oFile=document.querySelector('[type="file"]');
	oBtn.onclick = function() {
	    var xhr = new XMLHttpRequest();
	    xhr.onload = function() {
	        alert('OK,上传完成');
	    };
	    var oUp = xhr.upload;
	    oUp.onprogress = function(ev) {
	        var x = ev.loaded / ev.total;
	        oSpan.innerText = x * 100 + '%';
	    };
	    xhr.open('post', '1.php', true);
	    xhr.setRequestHeader('X-Request-With', 'XMLHttpRequest');
	    var oFormData = new FormData();
	    oFormData.append('file', oFile.files[0]);
	    xhr.send(oFormData);
	};

-----------------
	*websocket*
http连接是短连接，响应完成连接就结束了。不适合实时应用。只能用ajax定时请求来“伪实时”，但这样服务器端压力也很大。
web socket基于TCP的双向的、全双工的数据连接。
	双向：客户端、服务器端都能发
	全双工：数据的发送与接受，两者同步进行。

想要使用websocket，服务器端必须有相应的支持。

下面只讲基于nodejs服务器：
基于nodejs的websocket的模块也有有很多，下面只讲ws模块，github：https://github.com/websockets/ws
1 首先需要安装ws模块	
  进入服务器文件夹，在cmd中输入：npm install --save ws


以后需要再学吧：
http://blog.csdn.net/uniquelike/article/details/52574476

http://www.cnblogs.com/stoneniqiu/p/5402311.html

-----------------
	*应用程序缓存*
HTML5 引入了应用程序缓存，这意味着web应用可进行缓存，并可在没有因特网连接时进行访问。
优势：
  1 离线浏览 - 用户可在应用离线时使用它们
  2 速度 - 已缓存资源加载得更快
  3 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。

1 服务器端要设置头信息：text/cache-manifest
2 在文档的html标签中包含 manifest 属性：
  每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。
	<html manifest="demo.appcache">
3 Manifest 文件
	1 CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
	2 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
	3 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）
  实例：完整的 Manifest 文件
	CACHE MANIFEST
	# 2012-02-21 v1.0.0
	/theme.css
	/logo.gif
	/main.js

	NETWORK:
	login.php

	FALLBACK:
	/html/ /offline.html

4 更新缓存
	一旦应用被缓存，它就会保持缓存直到发生下列情况：
	用户清空浏览器缓存
	manifest 文件被修改
	由程序来更新应用缓存	
详细看runoob教程：http://www.runoob.com/html/html5-app-cache.html


-----------------
	*web worker*
当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。
web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。
1 检测浏览器是否支持 Web Worker
	if(typeof(Worker)!=="undefined")

2 web worker的限制：它们无法访问下例JavaScript 对象：
	window 对象、document 对象、parent 对象
	所以worker不能操作DOM对象，不能alert和console等。我们一般用worker来做大量的计算

3 使用：
  新建worker：new Worker(‘JS地址’)
  传数据：postMessage ev.data
  收数据：onmessage
  后台worker的js中想要引入其他js文件：importScripts(‘JS文件’)
  立刻停止worker：close()方法


3 例子：canvas中的“沫沫”用worker（已经放在wamp32的www中了）

详细看runoob教程：http://www.runoob.com/html/html5-webworkers.html
