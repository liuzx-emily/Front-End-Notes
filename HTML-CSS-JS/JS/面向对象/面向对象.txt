1 面向过程和面向对象编程
2 我们一直都在使用对象
  系统对象：数组Array  时间Date
3 面向对象编程(OOP)的特点
	抽象：抓住核心问题
	封装：只能通过对象来访问方法
	继承：从已有对象上继承出新的对象
	多态：多对象的不同形态
4 对象的组成
	属性——变量
	方法——函数
5 创建一个面向对象————工厂方式————构造函数模式————原型+构造模式
6 面向对象进阶：继承 组件（都是代码复用的不同方式）
7 ECMA6新加：class extends static super等
------------------
	*创建一个面向对象*

	var obj = new Object(); 
	obj.name = 'haha';
	obj.showName = function(){ 
	   alert(obj.name);
	}
	obj.showName();

缺点：当我们想创建多个面向对象的时候，重复代码过多，需要封装，所以有了：工厂方式

------------------
	*工厂方式*

	function CreatePerson(name){ 
		var obj = new Object();
		obj.name = name;
		obj.showName = function(){ 
			alert(this.name);
		}
		return obj;
	}
	var p1 = CreatePerson('haha');
	p1.showName();
	var p2 = CreatePerson('hehe');
	p2.showName();

这其实就是简单的封装函数，整个过程像工厂的流水线，所以叫工厂方式.

缺点：无法识别创建的对象的类型。因为全部都是Object，没有区分度，不像Date、Array等，因此出现了：构造函数模式。

------------------
	*构造函数模式*

当new去调用一个函数 : 这个时候函数中的this就是创建出来的对象,而且函数的的返回值直接就是this(隐式返回)。
new后面调用的函数 : 叫做构造函数。

我们要通过这二个方面来改变：1 函数名首字母大写  2 new 关键字调用

  	function CreatePerson(name){ 
  	     this.name = name; 
  	     this.showName = function(){ 
  	        alert(this.name); 
  	     } 
  	}
  	var p1 =new CreatePerson('haha'); 
	p1.showName();
	var p2 = new CreatePerson('hehe');
	p2.showName();	

1 首字母大写，是为了区别于普通的函数，构造函数本身就是普通的函数，只是我们专门用它来实现了构造的功能，所以专门起了一个名字叫构造函数，任何函数都可以成为构造函数，这取决于你调用函数的方式：是否用了new。

2 new关键字

  	function CreatePerson(name){   
  	  this.name = name; 
  	  this.showName = function(){ 
  	    alert(this.name); 
  	  };
  	  console.log(this);
  	}
  	new CreatePerson('haha'); 	//CreatePerson{}
  	CreatePerson('haha');  		//window

  我们会发现当用new去调用一个函数的时候，this的指向会不一样。其实new主要做了下面这些事，不过下面写的只是大概的行为，并不是内部源码。

  	function CreatePerson(name){   
  	  var res = {};  				//声明一个空对象res
  	  res.__proto__= CreatePerson.prototype;
  	  //这个对象的__proto__属性指向构造函数的原型对象,这样res就可以调用CreatePerson原型对象下的所有方法
  	  CreatePerson.apply(res);		//把this指向改为res对象
  	  this.name = name;  			//res对象添加属性，方法
  	  this.showName = function(){ 
  	    alert(this.name); 
  	  };
  	  return res;					//返回这个对象
  	}

3 函数构造模式的问题：
	alert(p1.showName==p2.showName);	//false
	(引用类型在比较时，是比较的地址)上面说明p1.showName和p2.showName这两个方法是不同的。每new一次，系统都会新创建一个内存，这两个对象各自有各自的地盘，这不是我们所希望的。所以就有了下一种方法：原型+构造模式

------------------
	*原型+构造模式*

1 每个函数都有一个prototype属性，它是一个对象，也称作"原型对象"。我们可以把方法和属性写在原型对象下面，通过这个函数创建出来的实例对象，都能共享原型对象下的方法和属性。
所以我们只需要把想要共享的东西放在函数的prototype下，不想共享的东西通过构造函数来创建就可以了。

	function CreatePerson(name){ 
	    this.name = name;
	}
	CreatePerson.prototype.showName = function(){ 
	    alert(this.name);
	}
	var p1 =new CreatePerson('haha');
	p1.showName();
	var p2 = new CreatePerson('hehe');
	p2.showName();
	alert(p1.showName==p2.showName);	//true

通过最后一句的测试为true，可以看到在构造函数的原型下面加的方法showName是所有通过这个构造函数创建出来的对象所共享的，也就是说他们共用一个内存，更进一步的说它们存在引用关系，也就是说你更改了p1的showName也会影响p2的showName。

所以我们在构造对象的时候，一般是‘原型+构造模式’。变化的不共用的用构造，不变的公用的用原型。

2 __proto__属性
  同一个构造函数创建出来的实例对象，可以共享这个函数的prototype下的方法和属性，这是如何做到的呢？
  每个实例化对象都有一个_proto_属性，它是一个指针，指向构造函数的原型对象prototype，也就是保存了prototype的地址。实例化对象通过这个属性，就可以拥有构造函数的原型对象下的所有属性和方法，_proto_属性实际就是实例化对象和构造函数的原型对象之间的连接。
  附注：JS中任何对象的值都是保存在堆内存中，我们声明的变量只是一个指针，保存了这个对象的实际地址，所以有了地址就能找到对象。

3 原型链
  每个函数都可以成为构造函数，每个函数都有原型对象，每个原型对象也可以是一个实例化对象。
  比如，你创建了一个函数fun1,它是构造函数Function的实例化对象。而Function的原型对象，又是Object的实例对象。所以fun1有个_proto_属性可以访问到Function的原型对象,Function原型对象也是个实例对象，也有个_proto_属性,可以访问到Object的原型对象。所以通过_proto_属性，就形成了一条原型链。每个实例化对象都可以访问到链子上方的方法和属性。所以fun1是可以访问Object原型对象下的方法和属性的。实际上所有对象都可以访问到Object的原型对象。

  	function fun1() {
  	   console.log('halo');
  	}
  	var fun2 = new fun1();		//halo

  	console.log( fun1.__proto__ === Function.prototype);//true
  	console.log( fun2.__proto__ === fun1.prototype);	//true
  	console.log( fun1 instanceof Function);				//true
  	console.log( fun2 instanceof fun1);					//true
  	console.log( fun2 instanceof Function);				//false
	console.log( fun2.constructor === fun2.__proto__.constructor); 		//true
  	console.log( fun2.constructor.__proto__ === Function.prototype);	//true

  原型链的访问规则：先在自身的下面寻找，再去一级一级的往原型链上找。如下:

	function Aaa(){
		this.num=11;
	}
	Aaa.prototype.num=22;
	Object.prototype.num=33;
	var a1=new Aaa();
	alert(a1.num);
	原型链：a1————Aaa.prototype————Object.prototype
	找a1.num时顺着原型链一级级向上找

4 原型对象下的方法和属性：
  原型对象下面可能有三大类：1 原型对象所带方法和属性   2 constructor   3 _proto_

5 原型对象的constructor属性：
  	constructor是每个函数的原型对象都有的默认属性，指向函数。
  	每个实例化对象本身是没有constructor属性的，每个实例化对象下面都默认只有一个_proto_,用来连接原型对象，而和构造函数本身是没有直接的联系的。所以它的constructor是访问的原型对象上的（因为实例化对象自己没有constructor这个属性，所以顺着原型链向上找）。
  	所以当原型对象的constructor变化了，实例化对象的constructor也会改变。
  	但是如果这个对象本身既是原型对象，又是实例化对象，那就拥有了constructor属性，无需从原型对象继承。

	function CreatePerson(name){
	   this.name = name;
	}
	CreatePerson.prototype.showName = function(){
	  console.log(this.name);
	};
	var p1 =new CreatePerson('haha');
	console.log(p1.constructor);  
	// CreatePerson
	分析：p1本身不是原型对象，没有constructor，从上面继承

	console.log(CreatePerson.prototype); 
	//  {showName:function(){}, constructor:CreatePerson, __proto__:Object.prototype}
	分析：原型对象保存了1  自身添加的方法，2 构造函数constructor  3 _proto_(和上一层构造函数原型对象的连接)

	console.log(CreatePerson.prototype.__proto__===Object.prototype);
	//  true
	console.log(CreatePerson.prototype.__proto__===Object);
	// false

	console.log(CreatePerson.prototype.constructor);
	//CreatePerson(name){this.name = name;}

	console.log(Object.prototype.__proto__); 
	// null     原型链的终点是null

	console.log(CreatePerson.__proto__===Function.prototype);   
	// true

	console.log(CreatePerson.constructor);
	//Function() { [native code] }

	console.log(CreatePerson.prototype instanceof CreatePerson ) 
	//false 验证是否在一条原型链上  


------------------
	*字面量法定义原型*

为了创建对象的代码更方便，你一定见过这样的代码，就是字面量法：

	function Aaa(){}
	Aaa.prototype = {
	    showName:function(){alert(10);}
	};
	 var a1 = new Aaa();
	console.log(Aaa.prototype);	//{showName:function(){},_proto_}

你会发现原型对象里的constructor属性不见了，因为这种方式相当于重新赋值了Aaa.prototype 

	console.log(Aaa.prototype.constructor);
	//Object() { [native code] }  	
	分析：因为自身没有了constructor属性，就去上级原型对象找，找到了Object
	console.log(a1.constructor );
	//Object() { [native code] }
	分析：也变了，验证了它是访问的原型对象上的

因此我们在写的时候需要修正一下原型的指向：
	function Aaa(){}
	Aaa.prototype = {
	  constructor:Aaa,
	  num1:function(){alert(10);}
	} 
	var a1 = new Aaa(); 
	a1.constructor // Aaa

注：不用担心__proto__属性，它一直都在

------------------
	*实例：面向对象的选项卡
原则：先写出普通的写法，然后改成面向对象写法
1 普通方法变型
	尽量不要出现函数嵌套函数
	可以有全局变量
	把onload中不是赋值的语句放到单独函数中
2 改成面向对象
	全局变量就是属性
	函数就是方法
		Onload中创建对象
		改this指向问题【重要】

------------------
	*实例：面向对象的拖拽
注意：
1 Event对象 必须在事件函数中
2 阻止默认事件的return false；也要放在事件函数中才行

----------------
	*包装对象*
一. 修改或者添加系统对象下面的方法和属性时，一定要谨慎
	var arr = [1, 2, 3];
	Array.prototype.push = function() {
	   console.log('push被修改啦');
	};
	arr.push(4, 5);		//push被修改啦
	console.log(arr);	//[1,2,3]
  自己实现原生的push方法：
	Array.prototype.push=function(){
		for(var i=0;i<arguments.length;i++){
			this[this.length]=arguments[i];
		}
		return this.length;
	}
  自己尝试实现原生的unshift方法：（易错）
  	Array.prototype.unshift = function() {
      var arr = [];
      for (var i = 0; i < arguments.length; i++) {
         arr[i] = arguments[i];
      }
      for (i = 0; i < this.length; i++) {
         arr[arr.length] = this[i];
      }
      for (var i = 0; i < arr.length; i++) {
         this[i] = arr[i];
      }
      //this=arr; this不能修改【这里易错】
      return this.length;
   };
  自己尝试实现原生的pop方法：
	Array.prototype.pop = function() {
		var x = this[this.length - 1];
		this.length--;
		return x;
	};
  自己尝试实现原生的shift方法：
	Array.prototype.shift = function() {
	   var x = this[0];
	   for (var i = 1; i < this.length; i++) {
	      this[i - 1] = this[i];
	   }
	   this.length--;
	   return x;
	};

2 包装对象
  值类型：number string boolean null undefined，前三种有包装对象:String Number Boolean
  	var str1 = 'hello';
  	var str2 = new String('hello');	//不推荐这么写
  	alert(typeof str1);	//string
  	alert(typeof str2);	//object
  调用属性、方法时：基本类型会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型，之后包装对象消失
  	String.prototype.liuzx=function(){
  		alert('所有string类型和String对象都可以调用这个');
  	}
  	var s1 = 'phil';
  	s1.liuzx();		//弹'所有...'
  	var s2 = new String('aaa');
  	s2.liuzx();		//弹'所有...'
  题目：
  	var str='Dunphy';
  	str.abc=123;
  	alert(str.abc);	//undefined
  	原因:
  		第1行：str是基本类型string。
  		第2行：新建属性abc：新建了一个包装对象S1，给S1赋属性S1.abc=123。然后包装对象S1消失。
  		第3行：又新建了一个包装对象S2,S2下没有属性abc，是undefined。

----------------
	hasOwnProperty方法
hasOwnProperty: 看是不是对象自身下面的属性、方法
hasOwnProperty是Object的方法
用法：对象.hasOwnProperty(属性或方法)
例子1：
	var arr=[];
	arr.num1=5;
	arr.fn1=function(){};
	Array.prototype.num2=9;
	Array.prototype.fn2=function(){};
	arr.hasOwnProperty('num1')	//true
	arr.hasOwnProperty('num2')	//false
	arr.hasOwnProperty('fn1')	//true
	arr.hasOwnProperty('fn2')	//false
注意：括号里的属性和方法名字一定要加引号
	对：arr.hasOwnProperty('num1')
	错：arr.hasOwnProperty(num1)


----------------
	constructor属性
1 任何函数都有属性prototype，被称为函数的原型对象(在创建函数时自动生成)
	function f1() {};
	console.log(f1.prototype);
2 原型对象下自动生成constructor属性，指向该函数。
例子1：
	function Aaa(){}
	var a1=new Aaa();
	alert(a1.constructor);	//Aaa
  原因：顺着原型链找：a1————Aaa.prototype————Object.prototpe。a1下没有constructor属性，在Aaa.prototype下找到了constructor属性。而Aaa.prototype.constructor=Aaa是创建函数Aaa时系统自动生成的。
例子2：
	Aaa.prototype = {
		name : '小明',
		age : 20
	};
	//这样Aaa.prototype下面就没有constructor了
	var a1=new Aaa();
	alert(a1.constructor);	//function Object(){[native code]}
3 for in循环不能遍历对象的所有属性，系统自动生成的不能被遍历到
	function Aaa(){}
	Aaa.prototype.name='小明';
	var a1 = new Aaa();
	for(var arr in a1){
		console.log(a1[arr]);	//遍历不到自动生成的constructor
	}


----------------
	instanceof运算符
判断对象与构造函数是不是在一条原型链上。
因为Object是原型链的最高级，所以任何对象 instanceof Object都是true。
例子：
	function Aaa() {}
	var a1 = new Aaa();
	alert(a1 instanceof Aaa); 		//true
	alert(a1 instanceof Object); 	//true
例子2：
	var str='hello';
	alert(str instanceof String);	//false
	因为str是字面值，不是对象


----------------
	toString方法
1 系统对象下面都是自带的
	var arr = [];
	alert(arr.toString==Object.prototype.toString); //false
2 自己写的对象都是通过原型链找Object下面的toString方法
	function Aaa(){}
	var a1 = new Aaa();
	alert(a1.toString==Object.prototype.toString);  //true
例：
	var arr = [1,2,3];
	Array.prototype.toString = function(){
		return this.join('+');
	};
	alert(arr.toString());  //1+2+3
3 Number的toString方法可以进行进制转换，例：
	var num = 255;
	alert( num.toString(16) );  //'ff'
4 利用toString做类型判断
	var arr=[];
	alert(Object.prototype.toString.call(arr)==='[object Array]');
  这样判断的好处：另外两种方法constructor和instanceof在iframe中会失效。
  	var oF = document.createElement('iframe');
  	document.body.appendChild( oF );  	
  	var ifArray = window.frames[0].Array;  	
  	var arr = new ifArray();  	
  	alert( arr.constructor == Array );  //false
	alert( arr instanceof Array );  //false
	alert( Object.prototype.toString.call(arr) == '[object Array]' );  //true

----------
	*ECMA6:类class
JS语言的传统方法是通过构造函数，定义并生成新对象，是一种基于原型的面向对象系统。这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的人感到困惑。所以，在ES6中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。

传统写法：
	const Emily = function(a, b) {
	    this.a = a;
	    this.b = b;
	};

	Emily.prototype = {
	    constructor: Emily,
	    print: function() {
	        console.log(this.a);
	    }
	};

class写法：
	class Emily{
		constructor(a,b){
			this.a=a;
			this.b=b;
		}
		print(){
			console.log(this.a)
		}
	};
使用还是和以前一样：
	var emily= new Emily("haha",23);
	emily.print();

说明：class只是语法糖
	1 类中的constructor方法是构造方法，this关键字则代表实例对象。

	2 类中定义方法的时候，前面不能加上function。另外，方法之间不能加逗号分隔

	3 构造函数的prototype属性，在ES6的“类”上面继续存在。而且类的所有方法都定义在类的prototype属性上面。

	4 定义在类中的方法都是不可以枚举的。
		console.log(Object.keys(Emily.prototype));

	5 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。类一定有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。

	6 生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果不加上new，像函数那样调用Class，将会报错。(ES5的写法，当函数调用不会报错)
