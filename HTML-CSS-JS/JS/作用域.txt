---------------------
	*作用域*
1 变量提升：函数和变量声明会被解释器悄悄地“提升”到方法体的最顶部。
	先提升var，值为undefined。
	再提升function，值为function(){内容}
	提升时重名的话：只留一个。
2 ECMA5只有两种作用域:全局、函数作用域
3 块中的function不能正常提升：
	块中所有（var和function）都是undefined

例子1:	
	for( var i=0; i<10; i++ ){
		aBtn[i].onclick = function (){	
			alert( i );		// undefined			
			for( var i=0; i<5; i++ ){
				...;
			}		
		};
	}
	alert(i);				// 10
		
例子2:	
	for( var i=0; i<7; i++ ){
		aBtn[i].onclick = function (){			
			alert( i );		// 7
		};
	}
	alert(i);				// 7

例子3:
	for (var i = 0; i < 7; i++) {
		var a = function() {
			console.log(i);      
			for (i = 0; i < 5; i++) {
				...;
			}		
		};
	}
	console.log(i);			// 7
	a();					// 7
	console.log(i);			// 5

例子4:
	 0-		a();
	 1-		console.log(a);
	 2-		var a = 1;
	 3-		console.log(a); 
	 4-		function a() { console.log(22); }
	 5-		console.log(a); 
	 6-		var a = 3;
	 7-		console.log(a);
	 8-		function a() { console.log(44); }
	 9-		console.log(a);
	 10-	a();
	分析:
	1 变量提升:
		最后a是function a (){ alert(44); }
	2 逐行解析代码:
		第零行:输出44
		第一行:输出[Function: a]
		第二行:a=1是表达式,可以修改a的值,把a由function变为变量1
		第三行:输出1
		第四行:不是表达式,不能修改a的值,什么都不发生
		第五行:输出1
		第六行:a=3是表达式,可以修改a的值,把a由1变为3
		第七行:输出3
		第八行:不是表达式,不能修改a的值,什么都不发生
		第九行:输出3
		第十行:报错:TypeError: a is not a function
	【难点:只有表达式可以修改值。so第四行函数定义不会修改a的值！！！】


例子1:
	function a(){alert(1);}
	function a(){alert(2);}
	var a=1;
	分析:变量提升最终a是function a(){alert(2);}

例子2:
	var a=1;
	var a="ok";
	分析:最终a是var,是undefined(只说变量提升时)

-----------------------
	*ECMA5中:block中定义的var和函数*
(有点迷糊,好像是ECMA5的,不确定。。)
只有函数会形成自己的域,其他的block｛｝不会。
变量提升对block中的var一切正常；但是对于函数,最新browser都可以提升block｛｝中的函数,但只会知道它是一个function,内容是undefined.
[注:是写在HTML里在浏览器的结果；不是运行纯js文件的结果]

例子0:
	console.log(i);		//undefined
	console.log(a);		//undefined
	for (var i = 0; i < 3; i++) {
		var a=5;
	}
	console.log(i);		//3
	console.log(a);		//5

例子1:
	alert(a);			//undefined
	alert(fn1);			//undefined,旧IE下是function fn1() {alert(5);}
	if (true) {
		var a = 1;
		function fn1() {
			alert(5);
		}
	}
	alert(a);			//1
	alert(fn1);			//function fn1() {alert(5);}

例子2:用来和1做对比
   alert(a);			//undefined
   alert(fn1);			//function fn1() {alert(5);}
   var a = 1;
   function fn1() {
		alert(5);
   }      
   alert(a);			//1
   alert(fn1);			//function fn1() {alert(5);}

所以：
1 对于函数，如果想要定义成全局的函数就乖乖写在外面,不要写在block｛｝内部。
2 对于var，虽然block内定义的var能正常,但还是写在外面逻辑更清晰。

------------------------------------
js的执行顺序是自上而下地执行，但是执行时却又分为两个环节
	1、词法分析期
	2、函数运行期
词法分析期：
	1、函数运行前的瞬间会生成个Active Object对象，下面简称为AO对象；
	2、声明函数的参数会作为AO的属性，此时值全为undefined；
	3、接收过来的实参作为对应的属性值
	4、分析变量声明，如果AO上已有此属性，则跳过，没有则添加该属性，属性值为undefined；
	5、分析函数声明，例如function aa（）{}则把aa赋给AO属性，即：AO.aa=function（）{}，当然，如果此前的AO对象中已经有了aa属性，则会被function覆盖掉。
执行期：
	从上到下，依次执行，变量从最近的函数体内开始找，扩散到外层函数，直到window对象中找，仍找不到即是undefined。

另外要说明的一点就是var a=function(){}和function a（）{}是有着本质区别的，前者明显的是个赋值的执行过程，后者是声明过程在我们的函数执行时，前者是发生在运行期的，而后者是发生在词法分析期。

1.	function t3(x,y) {  
		var x = 7;  
		console.log(x); 
		console.log(y); 
	}  
	t3(5);

2.	var str1='global';
	function t4() {
	    alert(str1);
	    alert(str2); 
	    var str2 = 'local'; 
	    alert(str2);
	}
	t4();

3.	function t(x,y) {
	    function x() {  
	        alert('hello');  
	    }
	    var y = 99;	  
	    alert(x); 
	    alert(y);
	} 
	t(3,4); 

1.	答案：7，undefined
	词法分析：
		1、创建临时AO对象，函数开始时分析形参，AO={x:undefined,y:undefined};
		2、分析实参，此时,AO={x:5,y:undefined};
		3、声明的x变量在AO中已经存在，故不作处理
		4、因为没有函数声明的过程，此题不考虑函数声明
		（词法分析期我们可以知道的是，x=5，y=undefined;下面开始运行期分析）
	运行期：由上到下执行语句为：
		1、var x = 7;        此时x=5被重新赋值，执行后x=7;
		1、console.log(x);   输出：7；
		2、console.log(y);   输出：undefined；

2.	答案：global,undefined,local
	词法分析：（分析顺序：形参，实参，变量声明，函数声明）；
		1、创建临时AO对象，函数开始时分析形参，此处没有形式参数;
		2、分析实参，此处没有实参;
		3、var str2，作为AO对象的属性，值为undefined；
		4、没有函数声明的过程，此题不考虑函数声明
		（词法分析期我们可以知道的是，AO={str2:undefined}下面开始运行期分析）
	运行期：由上到下执行语句为：
		1、alert(str1);           在内部未能找到str1变量的声明，在外部直到全局找，最后找到并输出：global
		1、alert(str2);           词法分析阶段可以知道，输出的是：undefined；
		2、var str2 = 'local';    对str2赋值，此时str2 = 'local';
		3、alert(str2);           输出：local;

3.	答案：function x(){alert('hello');}      99
	词法分析：（分析顺序：形参，实参，变量声明，函数声明）；
		1、创建临时AO对象，函数开始时分析形参，AO={x=undefined,y=undefined};
		2、分析实参,AO={x=3,y=4};
		3、var y已经在AO对象的有，跳过；
		4、函数声明function x(){},此时AO中x的值被赋值给了函数，即：AO={x:function(){},y:4};
	运行期：由上到下执行语句为：
		1、var y = 99;    y由4变成了99； 
		1、alert(x);      由第一阶段的分析很明显x是个function 
		1、alert(y);      输出99；

-----------------
	题目
1.	var a=6;
	setTimeout(function(){
	    alert(a);
	    a=666;
	},1000);
	a=66;

2.	var a = 6;
	setTimeout(function(a) {
	    alert(a);
	    a = 666;
	}, 1000, a);
	a = 66;

3. 	var a = 6;
  	setTimeout(function() {
  	    alert(a);
  	    var a = 666;
  	}, 1000);
  	a = 66;
	
4.	var a=1;
	function f(){
		alert(a);	
		var a=2;
	}
	f();
	alert(a);

5.	var a=1;
	function f(){
		alert(a);	
		a=2;
	}
	f();
	alert(a);

6.	var a=1;
	function f(a){
		alert(a);
		a=2;
	}
	f();
	alert(a);

7.	var a=1;
	function f(a){	
		alert(a);
		a=2;
	}
	f(a);
	alert(a);

8. 	var a = [1,2,3];
	function aaa(a){	
		a = [1,2,3,4]; 
	}
	aaa(a);
	alert(a);

9.	var a = [1,2,3];
	function aaa(a){	
		a.push(4); 
	}
	aaa(a);
	alert(a);

答案
1.	66
2.	6
3.	undefined
4.	undefined 1
5.	1 2
6.	undefined 1
7.	1 1
8.	1,2,3
9.	1,2,3,4

-----------------
题1：

	function aaa(){
		a = 10;
	}
	alert(a);
题2：
	function aaa(){
		a = 10;
	}
	aaa();
	alert(a);
题3：
	function aaa(){
		var a = b = 10;
	}
	aaa();
	alert(b);
	alert(a);

答案：
1. 报错：a没定义。
2. 10
3. 10
   报错：a没定义
	

分析：
  1	function aaa(){
		a = 10;
	}
  	全局中没有声明变量a时，函数aaa执行到a=10这一行时，会声明一个全局变量a。执行这一行之前，不会声明全局变量a。
  2 var a=b=10只声明了a，没有声明b

-----------------
题1：
   	var a = 10;
    function aaa() {
        alert(a);
    }
    function bbb() {
        var a = 20;
        aaa();
    }
    bbb();
题2：
	var a = 10;
	function bbb() {
		var a = 20;
		aaa();
		function aaa() {
			alert(a);
		}
	}
	bbb();


答案：
1. 10
2. 20

