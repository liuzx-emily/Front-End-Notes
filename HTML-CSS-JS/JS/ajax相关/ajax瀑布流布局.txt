  *瀑布流布局*
两种：
  1 列数固定：
  2 列数不固定：根据窗口大小而调整列数
这里只说列数固定的，假设列数为4
总体思路：
  1 用ajax动态添加数据，滚动条不断下拉，才不断加载更多内容
  2 所有内容都是通过ajax从后端获取、添加。最开始（ajax加载数据前），每一列中都没有内容，也就是列高为0。
  3 每一块请求：利用ajax获取数据，然后添加到一列后面appendChild。
  4 因为每块内容高度不确定，为了避免列高度相差太多。所以ajax添加块不是顺序依次加，而是计算列的高度，哪个列最“短”，就往它那加。
html结构：
  ul是整体,ul>li是一列,ul>li>div是一块内容
  ul>li>div>img是图片，ul>li>div>p是文字说明
  <ul>
    <li>
       <div>
          <img>
          <p></p>
       </div>
    </li>
    <li></li>
    <li></li>
    <li></li>
  </ul>

css样式：
  1 用float最无脑，用position:absolute要自己算位置。
    我自己写的用的是display:inline-block.
  2 写css样式前，先在html中手动加上内容结构用来测试css。css写好后，再删掉。
ajax：
  1 利用自己之前封装好的ajax函数，引入：<script src="ajax.js"></script>

  2 从后端拿数据：公司的后端会给前端提供数据获取接口。但如果没有提供，数据特别特别长，就要自己解决。
  url?cpage=1：取url中的第一页
  我们先看一下获取到的数据是什么样子的，先弹出page1的内容看看。
    var ajaxInfo = {
       url: 'getPics.php',
       data: 'cpage=1',
       method: 'get',
       fn: function(data) {
          alert(data);
       }
    };
    ajax(ajaxInfo);
  弹出的内容格式很乱，看着很烦。按F12——network，preview预览刚才请求的文件，可以看到浏览器帮你格式化好的内容。

  3 preview看过发现getPics.php的page1有0-49共50块数据，包含属性:height id image等等。需要逐条取出来，添加到height最小的列中。（别忘了先用parse转换格式）
    要先找出height最小的列：
    //找最矮的列
      function findShortest() {
        var index = 0;
        var iHeight = aLi[0].offsetHeight;
        for (var i = 1; i < aLi.length; i++) {
           if (aLi[i].offsetHeight < iHeight) {
              iHeight = aLi[i].offsetHeight;
              index = i;
           }
        }
        return index;
      }

  4 把ajax得到的数据添加到html中,修改ajaxInfo中定义的回调函数fn：

    fn: function(data1) {
       //data是string类型，必须先转换
       var data = JSON.parse(data1);
       if (data.length === 0) {
          return;
       }
       for (var i = 0; i < data.length; i++) {
          var oImg = document.createElement('img');
          oImg.src = data[i].image;
          var oP = document.createElement('p');
          oP.innerText = data[i].title;
          var oDiv = document.createElement('div');
          oDiv.appendChild(oImg);
          oDiv.appendChild(oP);
          aLi[findShortest()].appendChild(oDiv); //塞到最矮的列里
       }
       bFinish = true;
    }

 5 这样写还是有问题：由于图片加载有延时，没有把列的高度撑起来
   解决方法：用递归|给img设置宽高(需要后端支持，提供图片宽高数据).这里还没有学递归，so用第二种方法。
   列是固定宽度的，我们在css中已经设置了img的width:100%.
   不可以不设定高度，不能让它自动缩放（因为图片加载需要时间问题，没加载好时高度是0）,所以自己根据比例提前算一下高度。
  //188=800/4-（5+1）*2，是oImg的宽度
  oImg.style.height = data[i].height / data[i].width * 188 + 'px';  

 6 上面的没问题了。接着添加功能：滚动时，不断加载内容。
   加载新内容的条件：最短的那一列的底部，已经出现在可视区里了。
   获取每一列的高度（相对于整个html页面）：
   
    var iTopDistance = getPos(aLi[0]).top;
    //以前写的getPos函数，放到这里直接用
  function getPos(obj) {
    var pos = {
       left: 0,
       top: 0
    };
    while (obj) {
        pos.left += obj.offsetLeft;
        pos.top += obj.offsetTop;
        obj = obj.offsetParent;
    }
    return pos;
  }

   添加全局变量 var iPage;初始化为1。封装一个getMore()函数。
    var iPage = 1;
    function getMore() {
       ajaxInfo.data = 'cpage=' + iPage;
       ajax(ajaxInfo);
       iPage++;
    }

    添加窗口滚动事件：
    window.onscroll = function() {

        var iLi = iTopDistance + aLi[findShortest()].offsetHeight;
        var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;
      var iWin = document.documentElement.clientHeight + scrollTop;
      if (iLi - iWin <= 200) { //差200px就开始加载新内容
            getMore();
        }

    };

  7 还有问题：滚动加载内容是需要时间的。如果前面一批还没有加载完（列的高度没有被撑开时），又滚动，那么又会触发加载。这样会连着加载很多page。
  解决：添加全局变量来监控
  var bFinish = true; //判断当前cpage是否加载完成

  window.onscroll = function() {
        var iLi = iTopDistance + aLi[findShortest()].offsetHeight;
        var scrollTop = document.documentElement.scrollTop||document.body.scrollTop;
      var iWin = document.documentElement.clientHeight + scrollTop;
      if (iLi - iWin <= 200 && bFinish) {
          bFinish = false;
            getMore();
        }
    };

  在ajaxInfo的回调函数fn中最后添加：
  for (var i = 0; i < data.length; i++) {
    ...
  }
  bFinish = true;;//新加：这一page加载完成时改为true，允许加载新的

   8 还有问题：数据全部加载完了，要处理一下
    在ajaxInfo的回调函数fn开头：
      var data = JSON.parse(data);
      //新加：
      if (data.length === 0) {
         //后续没有数据了
         return;
      }

详情见：D:\wamp64\www\2 waterfall(记得测试一定要在服务器环境下：打开wampserver，输入localhost)
    （里面的waterfall.html是学完自己模仿写的）


附录：
  var oUl = document.getElementsByTagName('ul')[0];
  var aLi = oUl.getElementsByTagName('li');
  var iTopDistance = getPos(aLi[0]).top;
  var iPage = 1;
  var bFinish = true; //判断当前cpage是否加载完成
  var ajaxInfo = {
     url: 'getPics.php',
     data: 'cpage=1',
     method: 'get',
     fn: function(data1) {
        var data = JSON.parse(data1);
        if (data.length === 0) {
           return;
        }
        for (var i = 0; i < data.length; i++) {
           var oImg = document.createElement('img');
           oImg.src = data[i].image;
           oImg.style.height = data[i].height / data[i].width * 188 + 'px';
           //懒得自动获取了，188直接拿过来用了。只要css不变，就不用改
           //188=800/4-（5+1）*2
           var oP = document.createElement('p');
           oP.innerText = data[i].title;
           var oDiv = document.createElement('div');
           oDiv.appendChild(oImg);
           oDiv.appendChild(oP);
           aLi[findShortest()].appendChild(oDiv); //塞到最矮的列里
        }
        bFinish = true;
     }
  };
  getMore(); //刚开始加载一页数据

  window.onscroll = function() {

     var iLi = iTopDistance + aLi[findShortest()].offsetHeight;
     var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
     var iWin = document.documentElement.clientHeight + scrollTop;
     if (iLi - iWin <= 200 && bFinish) { //差200px就开始加载新内容
        bFinish = false;

        getMore();
     }

  };



  function getMore() {
     ajaxInfo.data = 'cpage=' + iPage;
     ajax(ajaxInfo);
     iPage++;
  }
  //找最矮的列
  function findShortest() {
     var index = 0;
     var iHeight = aLi[0].offsetHeight;
     for (var i = 1; i < aLi.length; i++) {
        if (aLi[i].offsetHeight < iHeight) {
           iHeight = aLi[i].offsetHeight;
           index = i;
        }
     }
     return index;
  }
  //以前写的getPos函数，放到这里直接用 getPos(aLi[0]).top
  function getPos(obj) {
     var pos = {
        left: 0,
        top: 0
     };
     while (obj) {
        pos.left += obj.offsetLeft;
        pos.top += obj.offsetTop;
        obj = obj.offsetParent;
     }
     return pos;
  }